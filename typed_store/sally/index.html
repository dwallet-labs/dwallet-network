<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Storage Atomicity Layer Library (aka Sally) is a wrapper around pluggable storage backends which implement a common key value interface. It enables users to switch storage backends in their code with simple options. It is also designed to be able to support atomic operations across different columns of the db even when they are backed by different storage instances."><title>typed_store::sally - Rust</title><link rel="preload" as="font" type="font/woff2" crossorigin href="../../static.files/SourceSerif4-Regular-46f98efaafac5295.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../static.files/FiraSans-Regular-018c141bf0843ffd.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../static.files/FiraSans-Medium-8f9a781e4970d388.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../static.files/SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../static.files/SourceSerif4-Bold-a2c9cd1067f8b328.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../static.files/SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2"><link rel="stylesheet" href="../../static.files/normalize-76eba96aa4d2e634.css"><link rel="stylesheet" href="../../static.files/rustdoc-2fcac8296ac587d8.css" id="mainThemeStyle"><div id="rustdoc-vars" data-root-path="../../" data-static-root-path="../../static.files/" data-current-crate="typed_store" data-themes="" data-resource-suffix="" data-rustdoc-version="1.72.0-nightly (8c74a5d27 2023-06-14)" data-search-js="search-c61faa3a19cfda94.js" data-settings-js="settings-de11bff964e9d4e5.js" data-settings-css="settings-8c76f75bfb6bd192.css" data-theme-light-css="light-0f8c037637f9eb3e.css" data-theme-dark-css="dark-1097f8e92a01e3cf.css" data-theme-ayu-css="ayu-614652228113ac93.css" ></div><script src="../../static.files/storage-62ce34ea385b278a.js"></script><script defer src="../../static.files/main-762bcae8c0777c4b.js"></script><noscript><link rel="stylesheet" media="(prefers-color-scheme:light)" href="../../static.files/light-0f8c037637f9eb3e.css"><link rel="stylesheet" media="(prefers-color-scheme:dark)" href="../../static.files/dark-1097f8e92a01e3cf.css"><link rel="stylesheet" href="../../static.files/noscript-13285aec31fa243e.css"></noscript><link rel="alternate icon" type="image/png" href="../../static.files/favicon-16x16-8b506e7a72182f1c.png"><link rel="alternate icon" type="image/png" href="../../static.files/favicon-32x32-422f7d1d52889060.png"><link rel="icon" type="image/svg+xml" href="../../static.files/favicon-2c020d218678b618.svg"></head><body class="rustdoc mod"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle">&#9776;</button><a class="logo-container" href="../../typed_store/index.html"><img class="rust-logo" src="../../static.files/rust-logo-151179464ae7ed46.svg" alt="logo"></a><h2></h2></nav><nav class="sidebar"><a class="logo-container" href="../../typed_store/index.html"><img class="rust-logo" src="../../static.files/rust-logo-151179464ae7ed46.svg" alt="logo"></a><h2 class="location"><a href="#">Module sally</a></h2><div class="sidebar-elems"><section><ul class="block"><li><a href="#structs">Structs</a></li><li><a href="#enums">Enums</a></li><li><a href="#functions">Functions</a></li></ul></section></div></nav><main><div class="width-limiter"><nav class="sub"><form class="search-form"><span></span><input class="search-input" name="search" aria-label="Run search in the documentation" autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"><div id="help-button" title="help" tabindex="-1"><a href="../../help.html">?</a></div><div id="settings-menu" tabindex="-1"><a href="../../settings.html" title="settings"><img width="22" height="22" alt="Change settings" src="../../static.files/wheel-7b819b6101059cd0.svg"></a></div></form></nav><section id="main-content" class="content"><div class="main-heading"><h1>Module <a href="../index.html">typed_store</a>::<wbr><a class="mod" href="#">sally</a><button id="copy-path" title="Copy item path to clipboard"><img src="../../static.files/clipboard-7571035ce49a181d.svg" width="19" height="18" alt="Copy item path"></button></h1><span class="out-of-band"><a class="srclink" href="../../src/typed_store/sally/mod.rs.html#4-573">source</a> · <button id="toggle-all-docs" title="collapse all docs">[<span>&#x2212;</span>]</button></span></div><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>Storage Atomicity Layer Library (aka Sally) is a wrapper around pluggable storage backends
which implement a common key value interface. It enables users to switch storage backends
in their code with simple options. It is also designed to be able to support atomic operations
across different columns of the db even when they are backed by different storage instances.</p>
<h2 id="examples"><a href="#examples">Examples</a></h2>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>typed_store::rocks::<span class="kw-2">*</span>;
<span class="kw">use </span>typed_store::<span class="kw-2">*</span>;
<span class="kw">use </span>typed_store::test_db::<span class="kw-2">*</span>;
<span class="kw">use </span>typed_store::sally::SallyDBOptions;
<span class="kw">use </span>typed_store_derive::SallyDB;
<span class="kw">use </span>typed_store::sally::SallyColumn;
<span class="kw">use </span>typed_store::traits::TypedStoreDebug;
<span class="kw">use </span>typed_store::traits::TableSummary;
<span class="kw">use </span><span class="kw">crate</span>::typed_store::Map;

<span class="comment">// `ExampleTable` is a sally db instance where each column is first initialized with TestDB
// (btree map) backend and later switched to a RocksDB column family

</span><span class="attr">#[derive(SallyDB)]
</span><span class="kw">pub struct </span>ExampleTable {
  col1: SallyColumn&lt;String, String&gt;,
  col2: SallyColumn&lt;i32, String&gt;,
}

<span class="kw">async fn </span>insert_key_vals(table: <span class="kw-2">&amp;</span>ExampleTable) {
    <span class="comment">// create a write batch and do atomic commit across columns in the table
    </span><span class="kw">let </span>keys_vals = (<span class="number">1</span>..<span class="number">100</span>).map(|i| (i, i.to_string()));
    <span class="kw">let </span><span class="kw-2">mut </span>wb = table.col1.batch();
    wb.insert_batch(<span class="kw-2">&amp;</span>table.col2, keys_vals).expect(<span class="string">&quot;Failed to batch insert&quot;</span>);
    wb.delete_range(<span class="kw-2">&amp;</span>table.col2, <span class="kw-2">&amp;</span><span class="number">50</span>, <span class="kw-2">&amp;</span><span class="number">100</span>).expect(<span class="string">&quot;Failed to batch delete&quot;</span>);
    wb.write().<span class="kw">await</span>.expect(<span class="string">&quot;Failed to commit batch&quot;</span>);
}

<span class="attr">#[tokio::main]
</span><span class="kw">async fn </span>main() -&gt; <span class="prelude-ty">Result</span>&lt;(), TypedStoreError&gt; {
    <span class="comment">// use a btree map backend first
    </span><span class="kw">let </span><span class="kw-2">mut </span>table = ExampleTable::init(SallyDBOptions::TestDB);
    insert_key_vals(<span class="kw-2">&amp;</span>table).<span class="kw">await</span>;
    <span class="comment">// switch to rocksdb backend
    </span><span class="kw">let </span>primary_path = tempfile::tempdir().expect(<span class="string">&quot;Failed to open db path&quot;</span>).into_path();
    table = ExampleTable::init(SallyDBOptions::RocksDB((primary_path, MetricConf::default(), RocksDBAccessType::Primary, <span class="prelude-val">None</span>, <span class="prelude-val">None</span>)));
    insert_key_vals(<span class="kw-2">&amp;</span>table).<span class="kw">await</span>;
    <span class="prelude-val">Ok</span>(())
}</code></pre></div>
</div></details><h2 id="structs" class="small-section-header"><a href="#structs">Structs</a></h2><ul class="item-table"><li><div class="item-name"><a class="struct" href="struct.SallyConfig.html" title="struct typed_store::sally::SallyConfig">SallyConfig</a></div></li><li><div class="item-name"><a class="struct" href="struct.SallyDBConfigMap.html" title="struct typed_store::sally::SallyDBConfigMap">SallyDBConfigMap</a></div></li></ul><h2 id="enums" class="small-section-header"><a href="#enums">Enums</a></h2><ul class="item-table"><li><div class="item-name"><a class="enum" href="enum.SallyColumn.html" title="enum typed_store::sally::SallyColumn">SallyColumn</a></div><div class="desc docblock-short">A Sally column could be anything that implements key value interface. We will eventually have
Sally serve read/writes using its own memtable and wal when columns in the db are backend by more then
one backend store (e.g different rocksdb instances and/or distributed key value stores)</div></li><li><div class="item-name"><a class="enum" href="enum.SallyColumnOptions.html" title="enum typed_store::sally::SallyColumnOptions">SallyColumnOptions</a></div><div class="desc docblock-short">Options to configure an individual column in a sally db instance</div></li><li><div class="item-name"><a class="enum" href="enum.SallyDBOptions.html" title="enum typed_store::sally::SallyDBOptions">SallyDBOptions</a></div><div class="desc docblock-short">Options to configure a sally db instance at the global level</div></li><li><div class="item-name"><a class="enum" href="enum.SallyIter.html" title="enum typed_store::sally::SallyIter">SallyIter</a></div><div class="desc docblock-short">A SallyIter provides an iterator over all key values in a sally column</div></li><li><div class="item-name"><a class="enum" href="enum.SallyKeys.html" title="enum typed_store::sally::SallyKeys">SallyKeys</a></div><div class="desc docblock-short">A SallyIter provides an iterator over all keys in a sally column</div></li><li><div class="item-name"><a class="enum" href="enum.SallyReadOnlyDBOptions.html" title="enum typed_store::sally::SallyReadOnlyDBOptions">SallyReadOnlyDBOptions</a></div><div class="desc docblock-short">Options to configure a sally db instance for performing read only operations at the global level</div></li><li><div class="item-name"><a class="enum" href="enum.SallyRevIter.html" title="enum typed_store::sally::SallyRevIter">SallyRevIter</a></div></li><li><div class="item-name"><a class="enum" href="enum.SallyRunMode.html" title="enum typed_store::sally::SallyRunMode">SallyRunMode</a></div></li><li><div class="item-name"><a class="enum" href="enum.SallyValues.html" title="enum typed_store::sally::SallyValues">SallyValues</a></div><div class="desc docblock-short">A SallyIter provides an iterator over all values in a sally column</div></li><li><div class="item-name"><a class="enum" href="enum.SallyWriteBatch.html" title="enum typed_store::sally::SallyWriteBatch">SallyWriteBatch</a></div><div class="desc docblock-short">A Sally write batch provides a mutable struct which holds a collection of db mutation operations and
applies them atomically to the db.
Once sally has its own memtable and wal, atomic commits across multiple db instances will be possible.</div></li></ul><h2 id="functions" class="small-section-header"><a href="#functions">Functions</a></h2><ul class="item-table"><li><div class="item-name"><a class="fn" href="fn.default_column_options.html" title="fn typed_store::sally::default_column_options">default_column_options</a></div><div class="desc docblock-short">Creates a default RocksDB option, to be used when RocksDB option is not specified..</div></li></ul></section></div></main></body></html>