use crate::validator_initialization_config::ValidatorInitializationConfig;
use anyhow::bail;
use dwallet_classgroups_types::ClassGroupsEncryptionKeyAndProof;
use fastcrypto::traits::ToFromBytes;
use ika_config::initiation::{InitiationParameters, MIN_VALIDATOR_JOINING_STAKE_INKU};
use ika_config::validator_info::ValidatorInfo;
use ika_config::Config;
use ika_move_packages::IkaMovePackage;
use ika_types::ika_coin::IKACoin;
use ika_types::messages_dwallet_mpc::{
    IkaPackagesConfig, DKG_FIRST_ROUND_PROTOCOL_FLAG, DKG_SECOND_ROUND_PROTOCOL_FLAG,
    FUTURE_SIGN_PROTOCOL_FLAG, IMPORTED_KEY_DWALLET_VERIFICATION_PROTOCOL_FLAG,
    MAKE_DWALLET_USER_SECRET_KEY_SHARE_PUBLIC_PROTOCOL_FLAG, PRESIGN_PROTOCOL_FLAG,
    RE_ENCRYPT_USER_SHARE_PROTOCOL_FLAG, SIGN_PROTOCOL_FLAG,
    SIGN_WITH_PARTIAL_USER_SIGNATURE_PROTOCOL_FLAG,
};
use ika_types::sui::system_inner_v1::ValidatorCapV1;
use ika_types::sui::{
    ClassGroupsPublicKeyAndProof, ClassGroupsPublicKeyAndProofBuilder, System,
    ADD_PAIR_TO_CLASS_GROUPS_PUBLIC_KEY_AND_PROOF_FUNCTION_NAME,
    CLASS_GROUPS_PUBLIC_KEY_AND_PROOF_MODULE_NAME,
    CREATE_CLASS_GROUPS_PUBLIC_KEY_AND_PROOF_BUILDER_FUNCTION_NAME,
    DWALLET_2PC_MPC_SECP256K1_MODULE_NAME, DWALLET_COORDINATOR_STRUCT_NAME,
    FINISH_CLASS_GROUPS_PUBLIC_KEY_AND_PROOF_FUNCTION_NAME, INITIALIZE_FUNCTION_NAME,
    INIT_CAP_STRUCT_NAME, INIT_MODULE_NAME, NEW_VALIDATOR_METADATA_FUNCTION_NAME,
    PROTOCOL_CAP_MODULE_NAME, PROTOCOL_CAP_STRUCT_NAME, REQUEST_ADD_STAKE_FUNCTION_NAME,
    REQUEST_ADD_VALIDATOR_CANDIDATE_FUNCTION_NAME, REQUEST_ADD_VALIDATOR_FUNCTION_NAME,
    REQUEST_DWALLET_NETWORK_DECRYPTION_KEY_DKG_BY_CAP_FUNCTION_NAME, SYSTEM_MODULE_NAME,
    VALIDATOR_CAP_MODULE_NAME, VALIDATOR_CAP_STRUCT_NAME, VALIDATOR_METADATA_MODULE_NAME,
};
use move_core_types::ident_str;
use move_core_types::language_storage::{StructTag, TypeTag};
use shared_crypto::intent::Intent;
use std::collections::HashMap;
use std::fs::File;
use std::io::Write;
use sui::client_commands::{
    estimate_gas_budget_from_gas_cost, execute_dry_run, request_tokens_from_faucet,
    SuiClientCommandResult,
};
use sui_config::SUI_CLIENT_CONFIG;
use sui_keys::keystore::{AccountKeystore, InMemKeystore, Keystore};
use sui_sdk::rpc_types::{ObjectChange, SuiObjectDataOptions, SuiTransactionBlockResponse};
use sui_sdk::rpc_types::{
    SuiObjectDataFilter, SuiObjectResponseQuery, SuiTransactionBlockEffectsAPI,
};
use sui_sdk::sui_client_config::{SuiClientConfig, SuiEnv};
use sui_sdk::wallet_context::WalletContext;
use sui_sdk::SuiClient;
use sui_types::base_types::{ObjectID, ObjectRef, SequenceNumber, SuiAddress};
use sui_types::coin::TreasuryCap;
use sui_types::crypto::{SignatureScheme, SuiKeyPair};
use sui_types::move_package::UpgradeCap;
use sui_types::object::Owner;
use sui_types::programmable_transaction_builder::ProgrammableTransactionBuilder;
use sui_types::transaction::{
    Argument, CallArg, Command, ObjectArg, SenderSignedData, Transaction, TransactionDataAPI,
    TransactionKind,
};
use sui_types::{
    MOVE_STDLIB_PACKAGE_ID, SUI_CLOCK_OBJECT_ID, SUI_CLOCK_OBJECT_SHARED_VERSION,
    SUI_FRAMEWORK_PACKAGE_ID,
};

const STAKED_IKA_ICON_URL: &str = "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxMDAwIiBoZWlnaHQ9IjEwMDAiIHZpZXdCb3g9IjAgMCAxMDAwIDEwMDAiIGZpbGw9Im5vbmUiPiA8ZyBjbGlwLXBhdGg9InVybCgjY2xpcDBfNjk5XzIyKSI+IDxwYXRoIGQ9Ik0wIDMwLjAwMTZDMCAxMy40MzMgMTMuNDMxNCAwIDMwIDBDMzQwLjI5NCAwIDY1MC44NTYgMCA5NjkuOTk4IDBDOTg2LjU2NyAwIDEwMDAgMTMuNDMxNCAxMDAwIDMwQzEwMDAgMzQwLjI5NCAxMDAwIDY1MC44NTYgMTAwMCA5NjkuOTk4QzEwMDAgOTg2LjU2NyA5ODYuNTY5IDEwMDAgOTcwIDEwMDBDNjU5LjcwNiAxMDAwIDM0OS4xNDQgMTAwMCAzMC4wMDE2IDEwMDBDMTMuNDMzIDEwMDAgMCA5ODYuNTY5IDAgOTcwQzAgNjU5LjcwNiAwIDM0OS4xNDQgMCAzMC4wMDE2WiIgZmlsbD0iI0VFMkI1QiIvPiA8cGF0aCBkPSJNNDUyIDE5NEM0ODMuNjggMTk0IDUxNS4zNiAxOTQgNTQ4IDE5NEM1NDggMjA0LjU2IDU0OCAyMTUuMTIgNTQ4IDIyNkM1NjkuNDUgMjI2IDU5MC45IDIyNiA2MTMgMjI2QzYxMyAyMzYuNTYgNjEzIDI0Ny4xMiA2MTMgMjU4QzYyMy41NiAyNTggNjM0LjEyIDI1OCA2NDUgMjU4QzY0NSAyNjguNTYgNjQ1IDI3OS4xMiA2NDUgMjkwQzY1NS41NiAyOTAgNjY2LjEyIDI5MCA2NzcgMjkwQzY3NyAzMDAuODkgNjc3IDMxMS43OCA2NzcgMzIzQzY4Ny44OSAzMjMgNjk4Ljc4IDMyMyA3MTAgMzIzQzcxMCA0MjkuMjYgNzEwIDUzNS41MiA3MTAgNjQ1QzczMS4xMiA2NDUgNzUyLjI0IDY0NSA3NzQgNjQ1Qzc3NCA2MDIuNDMgNzc0IDU1OS44NiA3NzQgNTE2Qzc5NS40NSA1MTYgODE2LjkgNTE2IDgzOSA1MTZDODM5IDU2OS4xMyA4MzkgNjIyLjI2IDgzOSA2NzdDODE3LjU1IDY3NyA3OTYuMSA2NzcgNzc0IDY3N0M3NzQgNjg3Ljg5IDc3NCA2OTguNzggNzc0IDcxMEM3NTIuODggNzEwIDczMS43NiA3MTAgNzEwIDcxMEM3MTAgNjk5LjExIDcxMCA2ODguMjIgNzEwIDY3N0M2OTkuMTEgNjc3IDY4OC4yMiA2NzcgNjc3IDY3N0M2NzcgNjY2LjQ0IDY3NyA2NTUuODggNjc3IDY0NUM2NjYuNDQgNjQ1IDY1NS44OCA2NDUgNjQ1IDY0NUM2NDUgNTM4Ljc0IDY0NSA0MzIuNDggNjQ1IDMyM0M2MzQuNDQgMzIzIDYyMy44OCAzMjMgNjEzIDMyM0M2MTMgMzEyLjExIDYxMyAzMDEuMjIgNjEzIDI5MEM1OTEuNTUgMjkwIDU3MC4xIDI5MCA1NDggMjkwQzU0OCAyNzkuNDQgNTQ4IDI2OC44OCA1NDggMjU4QzUxNi4zMiAyNTggNDg0LjY0IDI1OCA0NTIgMjU4QzQ1MiAyNjguNTYgNDUyIDI3OS4xMiA0NTIgMjkwQzQzMC41NSAyOTAgNDA5LjEgMjkwIDM4NyAyOTBDMzg3IDMwMC44OSAzODcgMzExLjc4IDM4NyAzMjNDMzc2LjQ0IDMyMyAzNjUuODggMzIzIDM1NSAzMjNDMzU1IDQyOS4yNiAzNTUgNTM1LjUyIDM1NSA2NDVDMzQ0LjQ0IDY0NSAzMzMuODggNjQ1IDMyMyA2NDVDMzIzIDY1NS41NiAzMjMgNjY2LjEyIDMyMyA2NzdDMzEyLjExIDY3NyAzMDEuMjIgNjc3IDI5MCA2NzdDMjkwIDY4Ny44OSAyOTAgNjk4Ljc4IDI5MCA3MTBDMjY4Ljg4IDcxMCAyNDcuNzYgNzEwIDIyNiA3MTBDMjI2IDY5OS4xMSAyMjYgNjg4LjIyIDIyNiA2NzdDMjA0LjU1IDY3NyAxODMuMSA2NzcgMTYxIDY3N0MxNjEgNjIzLjg3IDE2MSA1NzAuNzQgMTYxIDUxNkMxODIuNDUgNTE2IDIwMy45IDUxNiAyMjYgNTE2QzIyNiA1NTguNTcgMjI2IDYwMS4xNCAyMjYgNjQ1QzI0Ny4xMiA2NDUgMjY4LjI0IDY0NSAyOTAgNjQ1QzI5MCA1MzguNzQgMjkwIDQzMi40OCAyOTAgMzIzQzMwMC44OSAzMjMgMzExLjc4IDMyMyAzMjMgMzIzQzMyMyAzMTIuMTEgMzIzIDMwMS4yMiAzMjMgMjkwQzMzMy41NiAyOTAgMzQ0LjEyIDI5MCAzNTUgMjkwQzM1NSAyNzkuNDQgMzU1IDI2OC44OCAzNTUgMjU4QzM2NS41NiAyNTggMzc2LjEyIDI1OCAzODcgMjU4QzM4NyAyNDcuNDQgMzg3IDIzNi44OCAzODcgMjI2QzQwOC40NSAyMjYgNDI5LjkgMjI2IDQ1MiAyMjZDNDUyIDIxNS40NCA0NTIgMjA0Ljg4IDQ1MiAxOTRaIiBmaWxsPSJ3aGl0ZSIvPiA8cGF0aCBkPSJNNDg0IDU0OEM0OTQuNTYgNTQ4IDUwNS4xMiA1NDggNTE2IDU0OEM1MTYgNTU4Ljg5IDUxNiA1NjkuNzggNTE2IDU4MUM1MzcuNDUgNTgxIDU1OC45IDU4MSA1ODEgNTgxQzU4MSA2MDIuMTIgNTgxIDYyMy4yNCA1ODEgNjQ1QzU5MS41NiA2NDUgNjAyLjEyIDY0NSA2MTMgNjQ1QzYxMyA2ODcuNTcgNjEzIDczMC4xNCA2MTMgNzc0QzU5MS41NSA3NzQgNTcwLjEgNzc0IDU0OCA3NzRDNTQ4IDczMS40MyA1NDggNjg4Ljg2IDU0OCA2NDVDNTM3LjQ0IDY0NSA1MjYuODggNjQ1IDUxNiA2NDVDNTE2IDYzNC40NCA1MTYgNjIzLjg4IDUxNiA2MTNDNTA1LjQ0IDYxMyA0OTQuODggNjEzIDQ4NCA2MTNDNDg0IDYyMy41NiA0ODQgNjM0LjEyIDQ4NCA2NDVDNDczLjQ0IDY0NSA0NjIuODggNjQ1IDQ1MiA2NDVDNDUyIDY4Ny41NyA0NTIgNzMwLjE0IDQ1MiA3NzRDNDMwLjU1IDc3NCA0MDkuMSA3NzQgMzg3IDc3NEMzODcgNzMxLjQzIDM4NyA2ODguODYgMzg3IDY0NUMzOTcuNTYgNjQ1IDQwOC4xMiA2NDUgNDE5IDY0NUM0MTkgNjIzLjg4IDQxOSA2MDIuNzYgNDE5IDU4MUM0NDAuNDUgNTgxIDQ2MS45IDU4MSA0ODQgNTgxQzQ4NCA1NzAuMTEgNDg0IDU1OS4yMiA0ODQgNTQ4WiIgZmlsbD0id2hpdGUiLz4gPHBhdGggZD0iTTQ1MiAzODdDNDgzLjY4IDM4NyA1MTUuMzYgMzg3IDU0OCAzODdDNTQ4IDQxOS4wMSA1NDggNDUxLjAyIDU0OCA0ODRDNTM3LjQ0IDQ4NCA1MjYuODggNDg0IDUxNiA0ODRDNTE2IDQ3My40NCA1MTYgNDYyLjg4IDUxNiA0NTJDNTA1LjQ0IDQ1MiA0OTQuODggNDUyIDQ4NCA0NTJDNDg0IDQ0MS4xMSA0ODQgNDMwLjIyIDQ4NCA0MTlDNDczLjQ0IDQxOSA0NjIuODggNDE5IDQ1MiA0MTlDNDUyIDQwOC40NCA0NTIgMzk3Ljg4IDQ1MiAzODdaIiBmaWxsPSJ3aGl0ZSIvPiA8L2c+IDxkZWZzPiA8Y2xpcFBhdGggaWQ9ImNsaXAwXzY5OV8yMiI+IDxyZWN0IHdpZHRoPSIxMDAwIiBoZWlnaHQ9IjEwMDAiIGZpbGw9IndoaXRlIi8+IDwvY2xpcFBhdGg+IDwvZGVmcz4gPC9zdmc+";
const DWALLET_CAP_IMAGE_URL: &str = "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxMDAwIiBoZWlnaHQ9IjEwMDAiIHZpZXdCb3g9IjAgMCAxMDAwIDEwMDAiIGZpbGw9Im5vbmUiPiA8ZyBjbGlwLXBhdGg9InVybCgjY2xpcDBfNzAzXzMwKSI+IDxwYXRoIGQ9Ik0wIDBDMzMwIDAgNjYwIDAgMTAwMCAwQzEwMDAgMzMwIDEwMDAgNjYwIDEwMDAgMTAwMEM2NzAgMTAwMCAzNDAgMTAwMCAwIDEwMDBDMCA2NzAgMCAzNDAgMCAwWiIgZmlsbD0iI0VFMkI1QiIvPiA8cGF0aCBkPSJNMjQxIDM0MUM0MTIuMjcgMzQxIDU4My41NCAzNDEgNzYwIDM0MUM3NjAgNDc5LjI3IDc2MCA2MTcuNTQgNzYwIDc2MEM1ODguNzMgNzYwIDQxNy40NiA3NjAgMjQxIDc2MEMyNDEgNjIxLjczIDI0MSA0ODMuNDYgMjQxIDM0MVoiIGZpbGw9IiNFRTJCNUIiLz4gPHBhdGggZD0iTTIwMCAyMDBDMjEzLjUzIDIwMCAyMjcuMDYgMjAwIDI0MSAyMDBDMjQxIDIzMyAyNDEgMjY2IDI0MSAzMDBDNDEyLjI3IDMwMCA1ODMuNTQgMzAwIDc2MCAzMDBDNzYwIDI2NyA3NjAgMjM0IDc2MCAyMDBDNzczLjUzIDIwMCA3ODcuMDYgMjAwIDgwMSAyMDBDODAxIDM4NC44IDgwMSA1NjkuNiA4MDEgNzYwQzc4Ny40NyA3NjAgNzczLjk0IDc2MCA3NjAgNzYwQzc2MCA2MjEuNzMgNzYwIDQ4My40NiA3NjAgMzQxQzU4OC43MyAzNDEgNDE3LjQ2IDM0MSAyNDEgMzQxQzI0MSA0NzkuMjcgMjQxIDYxNy41NCAyNDEgNzYwQzIyNy40NyA3NjAgMjEzLjk0IDc2MCAyMDAgNzYwQzIwMCA1NzUuMiAyMDAgMzkwLjQgMjAwIDIwMFoiIGZpbGw9IndoaXRlIi8+IDxwYXRoIGQ9Ik0yNDEgNzYwQzQxMi4yNyA3NjAgNTgzLjU0IDc2MCA3NjAgNzYwQzc2MCA3NzMuNTMgNzYwIDc4Ny4wNiA3NjAgODAxQzU4OC43MyA4MDEgNDE3LjQ2IDgwMSAyNDEgODAxQzI0MSA3ODcuNDcgMjQxIDc3My45NCAyNDEgNzYwWiIgZmlsbD0id2hpdGUiLz4gPHBhdGggZD0iTTY1MCAyMjBDNjYzLjUzIDIyMCA2NzcuMDYgMjIwIDY5MSAyMjBDNjkxIDIzMy41MyA2OTEgMjQ3LjA2IDY5MSAyNjFDNjc3LjQ3IDI2MSA2NjMuOTQgMjYxIDY1MCAyNjFDNjUwIDI0Ny40NyA2NTAgMjMzLjk0IDY1MCAyMjBaIiBmaWxsPSJ3aGl0ZSIvPiA8L2c+IDxkZWZzPiA8Y2xpcFBhdGggaWQ9ImNsaXAwXzcwM18zMCI+IDxyZWN0IHdpZHRoPSIxMDAwIiBoZWlnaHQ9IjEwMDAiIGZpbGw9IndoaXRlIi8+IDwvY2xpcFBhdGg+IDwvZGVmcz4gPC9zdmc+";
const IMPORTED_KEY_DWALLET_CAP_IMAGE_URL: &str = "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxMDAwIiBoZWlnaHQ9IjEwMDAiIHZpZXdCb3g9IjAgMCAxMDAwIDEwMDAiIGZpbGw9Im5vbmUiPiA8ZyBjbGlwLXBhdGg9InVybCgjY2xpcDBfNzEwXzM0KSI+IDxwYXRoIGQ9Ik0wIDBDMzMwIDAgNjYwIDAgMTAwMCAwQzEwMDAgMzMwIDEwMDAgNjYwIDEwMDAgMTAwMEM2NzAgMTAwMCAzNDAgMTAwMCAwIDEwMDBDMCA2NzAgMCAzNDAgMCAwWiIgZmlsbD0iI0VFMkI1QiIvPiA8cGF0aCBkPSJNMjY5LjkzMyAzODQuNTIzQzMxOC4xNjUgMzg0LjA3NiAzNjYuMzk4IDM4My42MjggNDE2LjA5MiAzODMuMTY3QzQxNi44MDkgMzk4LjY2NyA0MTYuODA5IDM5OC42NjcgNDE2LjgyNiA0MDUuMjIyQzQxNi44MyA0MDUuOTA2IDQxNi44MzQgNDA2LjU5IDQxNi44MzkgNDA3LjI3NEM0MTYuODQ4IDQwOC44ODkgNDE2Ljg1NSA0MTAuNTAzIDQxNi44NTkgNDEyLjExN0M0MTcuMjc3IDQxMi4xMTEgNDE3LjY5NiA0MTIuMTA0IDQxOC4xMjcgNDEyLjA5OEM0MTkuNzQ5IDQxMi4wNzQgNDIxLjM3MSA0MTIuMDUzIDQyMi45OTQgNDEyLjAzM0M0MjQuMDEzIDQxMi4wMiA0MjUuMDMyIDQxMi4wMDQgNDI2LjA1MSA0MTEuOTg4QzQzMi40OSA0MTEuOTEzIDQzOC44NCA0MTIuMTU0IDQ0NS4yOTggNDEyLjM1M0M0NDUuNDc2IDQzMS42MjggNDQ1LjY1NSA0NTAuOTAzIDQ0NS44NCA0NzAuNzYyQzUxMC4yMDUgNDcwLjE2NSA1NzQuNTY5IDQ2OS41NjggNjQwLjg4NSA0NjguOTUyQzY0MC43MDcgNDQ5Ljg0MiA2NDAuNTMgNDMwLjczMSA2NDAuMzQ3IDQxMS4wNDJDNjQ5Ljg2MyA0MTAuOTUzIDY1OS4yODkgNDEwLjkwNSA2NjguNzg2IDQxMS4yNzdDNjY4LjkyNSA0MTcuMDkgNjY5LjA2MiA0MjIuOTAzIDY2OS4xOTcgNDI4LjcxNkM2NjkuMjA3IDQyOS4xNDQgNjY5LjIxNyA0MjkuNTcxIDY2OS4yMjcgNDMwLjAxMUM2NjkuNTI4IDQ0My4wNjkgNjY5Ljc1MiA0NTYuMTIxIDY2OS44MjIgNDY5LjE4M0M2NzkuNTM0IDQ2OS4wOTMgNjg5LjI0NyA0NjkuMDAzIDY5OS4yNTMgNDY4LjkxQzY5OS4wNzMgNDQ5LjQ3IDY5OC44OTIgNDMwLjAzIDY5OC43MDYgNDEwLjAwMUM3MTUuMzM4IDQwOS44NDYgNzE1LjMzOCA0MDkuODQ2IDcyMS4wNjMgNDEwLjA0M0M3MjIuMTQ4IDQxMC4wNzggNzIzLjIzMyA0MTAuMTEyIDcyNC4zMTggNDEwLjE0NkM3MjUuMjYgNDEwLjE3NiA3MjYuMjAyIDQxMC4yMDYgNzI3LjE0NSA0MTAuMjM2QzcyNy44MzMgNDIxLjk5OCA3MjcuOTIzIDQzMy43NTYgNzI4LjAwNiA0NDUuNTM1QzcyOC4wMjcgNDQ4LjU0NiA3MjguMDUzIDQ1MS41NTcgNzI4LjA3OCA0NTQuNTY4QzcyOC4xMTUgNDU5LjA5MiA3MjguMTQ4IDQ2My42MTcgNzI4LjE4MSA0NjguMTQyQzczNy44OTMgNDY4LjA1MiA3NDcuNjA2IDQ2Ny45NjIgNzU3LjYxMiA0NjcuODY5Qzc1Ny45NTkgNDg3LjQ3MiA3NTguMzA2IDUwNy4wNzUgNzU4LjY2MyA1MjcuMjcyQzY1NS43NzggNTI4LjIyNyA1NTIuODkzIDUyOS4xODIgNDQ2Ljg5IDUzMC4xNjZDNDQ3LjIzMiA1NDkuMjc1IDQ0Ny41NzQgNTY4LjM4NCA0NDcuOTI2IDU4OC4wNzJDNDMzLjAyIDU4OC43ODQgNDMzLjAyIDU4OC43ODQgNDI1LjkyIDU4OC44MDZDNDIzLjQ3MSA1ODguODE5IDQyMS4wMjIgNTg4LjgzMSA0MTguNDk5IDU4OC44NDRDNDE4Ljc1NCA1OTguNTYzIDQxOS4wMDkgNjA4LjI4MSA0MTkuMjcyIDYxOC4yOTRDMzcwLjU0NSA2MTguNzQ2IDMyMS44MTkgNjE5LjE5OCAyNzEuNjE2IDYxOS42NjRDMjcxLjUyNiA2MDkuOTQ0IDI3MS40MzYgNjAwLjIyNCAyNzEuMzQzIDU5MC4yMUMyNjEuOTYgNTkwLjI5NyAyNTIuNTc2IDU5MC4zODQgMjQyLjkwOSA1OTAuNDc0QzI0Mi4zNjkgNTMyLjMxOSAyNDEuODMgNDc0LjE2NCAyNDEuMjczIDQxNC4yNDZDMjUwLjgyMSA0MTQuMTU4IDI2MC4zNjkgNDE0LjA2OSAyNzAuMjA2IDQxMy45NzhDMjcwLjExNiA0MDQuMjU4IDI3MC4wMjUgMzk0LjUzOCAyNjkuOTMzIDM4NC41MjNaIiBmaWxsPSIjRkVGRUZFIi8+IDxwYXRoIGQ9Ik0zMDAuMTE5IDQ0Mi44MjNDMzI5LjExMyA0NDIuNTU0IDM1OC4xMDggNDQyLjI4NSAzODcuOTgxIDQ0Mi4wMDhDMzg4LjM0MiA0ODAuOTQzIDM4OC43MDQgNTE5Ljg3OSAzODkuMDc2IDU1OS45OTRDMzYwLjA4MiA1NjAuMjYzIDMzMS4wODcgNTYwLjUzMyAzMDEuMjE0IDU2MC44MUMzMDAuODUyIDUyMS44NzQgMzAwLjQ5MSA0ODIuOTM5IDMwMC4xMTkgNDQyLjgyM1oiIGZpbGw9IiNFRTJCNUIiLz4gPC9nPiA8ZGVmcz4gPGNsaXBQYXRoIGlkPSJjbGlwMF83MTBfMzQiPiA8cmVjdCB3aWR0aD0iMTAwMCIgaGVpZ2h0PSIxMDAwIiBmaWxsPSJ3aGl0ZSIvPiA8L2NsaXBQYXRoPiA8L2RlZnM+IDwvc3ZnPg==";
const UNVERIFIED_PRESIGN_CAP_IMAGE_URL: &str = "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxMDAwIiBoZWlnaHQ9IjEwMDAiIHZpZXdCb3g9IjAgMCAxMDAwIDEwMDAiIGZpbGw9Im5vbmUiPiA8ZyBjbGlwLXBhdGg9InVybCgjY2xpcDBfNzA0XzcyKSI+IDxwYXRoIGQ9Ik0wIDBDMzMwIDAgNjYwIDAgMTAwMCAwQzEwMDAgMzMwIDEwMDAgNjYwIDEwMDAgMTAwMEM2NzAgMTAwMCAzNDAgMTAwMCAwIDEwMDBDMCA2NzAgMCAzNDAgMCAwWiIgZmlsbD0iI0VFMkI1QiIvPiA8cGF0aCBkPSJNNDIyIDY3MkM0NzMuNTYyIDY3MiA1MjUuMTI1IDY3MiA1NzguMjUgNjcyQzU3OC4yNSA2ODIuMzEzIDU3OC4yNSA2OTIuNjI1IDU3OC4yNSA3MDMuMjVDNTI2LjY4OCA3MDMuMjUgNDc1LjEyNSA3MDMuMjUgNDIyIDcwMy4yNUM0MjIgNjkyLjkzOCA0MjIgNjgyLjYyNSA0MjIgNjcyWiIgZmlsbD0id2hpdGUiLz4gPHBhdGggZD0iTTY0MC43NSA1NzguMjVDNjUxLjA2MyA1NzguMjUgNjYxLjM3NSA1NzguMjUgNjcyIDU3OC4yNUM2NzIgNTk4Ljg3NSA2NzIgNjE5LjUgNjcyIDY0MC43NUM2NjEuNjg4IDY0MC43NSA2NTEuMzc1IDY0MC43NSA2NDAuNzUgNjQwLjc1QzY0MC43NSA2NTEuMDYzIDY0MC43NSA2NjEuMzc1IDY0MC43NSA2NzJDNjIwLjEyNSA2NzIgNTk5LjUgNjcyIDU3OC4yNSA2NzJDNTc4LjI1IDY2MS42ODggNTc4LjI1IDY1MS4zNzUgNTc4LjI1IDY0MC43NUM1ODguNTYzIDY0MC43NSA1OTguODc1IDY0MC43NSA2MDkuNSA2NDAuNzVDNjA5LjUgNjMwLjQzOCA2MDkuNSA2MjAuMTI1IDYwOS41IDYwOS41QzYxOS44MTMgNjA5LjUgNjMwLjEyNSA2MDkuNSA2NDAuNzUgNjA5LjVDNjQwLjc1IDU5OS4xODggNjQwLjc1IDU4OC44NzUgNjQwLjc1IDU3OC4yNVoiIGZpbGw9IndoaXRlIi8+IDxwYXRoIGQ9Ik0zMjguMjUgNTc4LjI1QzMzOC41NjMgNTc4LjI1IDM0OC44NzUgNTc4LjI1IDM1OS41IDU3OC4yNUMzNTkuNSA1ODguNTYzIDM1OS41IDU5OC44NzUgMzU5LjUgNjA5LjVDMzY5LjgxMyA2MDkuNSAzODAuMTI1IDYwOS41IDM5MC43NSA2MDkuNUMzOTAuNzUgNjE5LjgxMyAzOTAuNzUgNjMwLjEyNSAzOTAuNzUgNjQwLjc1QzQwMS4wNjMgNjQwLjc1IDQxMS4zNzUgNjQwLjc1IDQyMiA2NDAuNzVDNDIyIDY1MS4wNjMgNDIyIDY2MS4zNzUgNDIyIDY3MkM0MDEuMzc1IDY3MiAzODAuNzUgNjcyIDM1OS41IDY3MkMzNTkuNSA2NjEuNjg4IDM1OS41IDY1MS4zNzUgMzU5LjUgNjQwLjc1QzM0OS4xODggNjQwLjc1IDMzOC44NzUgNjQwLjc1IDMyOC4yNSA2NDAuNzVDMzI4LjI1IDYyMC4xMjUgMzI4LjI1IDU5OS41IDMyOC4yNSA1NzguMjVaIiBmaWxsPSJ3aGl0ZSIvPiA8cGF0aCBkPSJNNjcyIDQyMkM2ODIuMzEzIDQyMiA2OTIuNjI1IDQyMiA3MDMuMjUgNDIyQzcwMy4yNSA0NzMuNTYyIDcwMy4yNSA1MjUuMTI1IDcwMy4yNSA1NzguMjVDNjkyLjkzOCA1NzguMjUgNjgyLjYyNSA1NzguMjUgNjcyIDU3OC4yNUM2NzIgNTI2LjY4OCA2NzIgNDc1LjEyNSA2NzIgNDIyWiIgZmlsbD0id2hpdGUiLz4gPHBhdGggZD0iTTI5NyA0MjJDMzA3LjMxMyA0MjIgMzE3LjYyNSA0MjIgMzI4LjI1IDQyMkMzMjguMjUgNDczLjU2MiAzMjguMjUgNTI1LjEyNSAzMjguMjUgNTc4LjI1QzMxNy45MzggNTc4LjI1IDMwNy42MjUgNTc4LjI1IDI5NyA1NzguMjVDMjk3IDUyNi42ODggMjk3IDQ3NS4xMjUgMjk3IDQyMloiIGZpbGw9IndoaXRlIi8+IDxwYXRoIGQ9Ik01NzguMjUgMzI4LjI1QzU5OC44NzUgMzI4LjI1IDYxOS41IDMyOC4yNSA2NDAuNzUgMzI4LjI1QzY0MC43NSAzMzguNTYzIDY0MC43NSAzNDguODc1IDY0MC43NSAzNTkuNUM2NTEuMDYzIDM1OS41IDY2MS4zNzUgMzU5LjUgNjcyIDM1OS41QzY3MiAzODAuMTI1IDY3MiA0MDAuNzUgNjcyIDQyMkM2NjEuNjg4IDQyMiA2NTEuMzc1IDQyMiA2NDAuNzUgNDIyQzY0MC43NSA0MTEuNjg4IDY0MC43NSA0MDEuMzc1IDY0MC43NSAzOTAuNzVDNjMwLjQzOCAzOTAuNzUgNjIwLjEyNSAzOTAuNzUgNjA5LjUgMzkwLjc1QzYwOS41IDM4MC40MzggNjA5LjUgMzcwLjEyNSA2MDkuNSAzNTkuNUM1OTkuMTg4IDM1OS41IDU4OC44NzUgMzU5LjUgNTc4LjI1IDM1OS41QzU3OC4yNSAzNDkuMTg4IDU3OC4yNSAzMzguODc1IDU3OC4yNSAzMjguMjVaIiBmaWxsPSJ3aGl0ZSIvPiA8cGF0aCBkPSJNMzU5LjUgMzI4LjI1QzM4MC4xMjUgMzI4LjI1IDQwMC43NSAzMjguMjUgNDIyIDMyOC4yNUM0MjIgMzM4LjU2MyA0MjIgMzQ4Ljg3NSA0MjIgMzU5LjVDNDExLjY4OCAzNTkuNSA0MDEuMzc1IDM1OS41IDM5MC43NSAzNTkuNUMzOTAuNzUgMzY5LjgxMyAzOTAuNzUgMzgwLjEyNSAzOTAuNzUgMzkwLjc1QzM4MC40MzggMzkwLjc1IDM3MC4xMjUgMzkwLjc1IDM1OS41IDM5MC43NUMzNTkuNSA0MDEuMDYzIDM1OS41IDQxMS4zNzUgMzU5LjUgNDIyQzM0OS4xODggNDIyIDMzOC44NzUgNDIyIDMyOC4yNSA0MjJDMzI4LjI1IDQwMS4zNzUgMzI4LjI1IDM4MC43NSAzMjguMjUgMzU5LjVDMzM4LjU2MyAzNTkuNSAzNDguODc1IDM1OS41IDM1OS41IDM1OS41QzM1OS41IDM0OS4xODggMzU5LjUgMzM4Ljg3NSAzNTkuNSAzMjguMjVaIiBmaWxsPSJ3aGl0ZSIvPiA8cGF0aCBkPSJNNDIyIDI5N0M0NzMuNTYyIDI5NyA1MjUuMTI1IDI5NyA1NzguMjUgMjk3QzU3OC4yNSAzMDcuMzEzIDU3OC4yNSAzMTcuNjI1IDU3OC4yNSAzMjguMjVDNTI2LjY4OCAzMjguMjUgNDc1LjEyNSAzMjguMjUgNDIyIDMyOC4yNUM0MjIgMzE3LjkzOCA0MjIgMzA3LjYyNSA0MjIgMjk3WiIgZmlsbD0id2hpdGUiLz4gPC9nPiA8ZGVmcz4gPGNsaXBQYXRoIGlkPSJjbGlwMF83MDRfNzIiPiA8cmVjdCB3aWR0aD0iMTAwMCIgaGVpZ2h0PSIxMDAwIiBmaWxsPSJ3aGl0ZSIvPiA8L2NsaXBQYXRoPiA8L2RlZnM+IDwvc3ZnPg==";
const VERIFIED_PRESIGN_CAP_IMAGE_URL: &str = "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxMDAwIiBoZWlnaHQ9IjEwMDAiIHZpZXdCb3g9IjAgMCAxMDAwIDEwMDAiIGZpbGw9Im5vbmUiPiA8ZyBjbGlwLXBhdGg9InVybCgjY2xpcDBfNzA5XzMyKSI+IDxwYXRoIGQ9Ik0wIDBDMzMwIDAgNjYwIDAgMTAwMCAwQzEwMDAgMzMwIDEwMDAgNjYwIDEwMDAgMTAwMEM2NzAgMTAwMCAzNDAgMTAwMCAwIDEwMDBDMCA2NzAgMCAzNDAgMCAwWiIgZmlsbD0iI0VFMkI1QiIvPiA8cGF0aCBkPSJNNTYwIDU4MEM1NzMuMiA1ODAgNTg2LjQgNTgwIDYwMCA1ODBDNjAwIDU5My4yIDYwMCA2MDYuNCA2MDAgNjIwQzU4Ni44IDYyMCA1NzMuNiA2MjAgNTYwIDYyMEM1NjAgNjA2LjggNTYwIDU5My42IDU2MCA1ODBaIiBmaWxsPSIjRUUyQjVCIi8+IDxwYXRoIGQ9Ik00MDAgNTgwQzQxMy4yIDU4MCA0MjYuNCA1ODAgNDQwIDU4MEM0NDAgNTkzLjIgNDQwIDYwNi40IDQ0MCA2MjBDNDI2LjggNjIwIDQxMy42IDYyMCA0MDAgNjIwQzQwMCA2MDYuOCA0MDAgNTkzLjYgNDAwIDU4MFoiIGZpbGw9IiNFRTJCNUIiLz4gPHBhdGggZD0iTTUyMCA1NDBDNTMzLjIgNTQwIDU0Ni40IDU0MCA1NjAgNTQwQzU2MCA1NTMuMiA1NjAgNTY2LjQgNTYwIDU4MEM1NDYuOCA1ODAgNTMzLjYgNTgwIDUyMCA1ODBDNTIwIDU2Ni44IDUyMCA1NTMuNiA1MjAgNTQwWiIgZmlsbD0iI0VFMkI1QiIvPiA8cGF0aCBkPSJNNDQwIDU0MEM0NTMuMiA1NDAgNDY2LjQgNTQwIDQ4MCA1NDBDNDgwIDU1My4yIDQ4MCA1NjYuNCA0ODAgNTgwQzQ2Ni44IDU4MCA0NTMuNiA1ODAgNDQwIDU4MEM0NDAgNTY2LjggNDQwIDU1My42IDQ0MCA1NDBaIiBmaWxsPSIjRUUyQjVCIi8+IDxwYXRoIGQ9Ik00ODAgNTAwQzQ5My4yIDUwMCA1MDYuNCA1MDAgNTIwIDUwMEM1MjAgNTEzLjIgNTIwIDUyNi40IDUyMCA1NDBDNTA2LjggNTQwIDQ5My42IDU0MCA0ODAgNTQwQzQ4MCA1MjYuOCA0ODAgNTEzLjYgNDgwIDUwMFoiIGZpbGw9IiNFRTJCNUIiLz4gPC9nPiA8cGF0aCBkPSJNNzMyLjM4OSA0MDhDNzUyLjM5MSA0MDggNzcyLjM5MiA0MDggNzkzIDQwOEM3OTMgNDI4LjMyNiA3OTMgNDQ4LjY1MyA3OTMgNDY5LjU5NUM3ODMuMTI5IDQ2OS41OTUgNzczLjI1OCA0NjkuNTk1IDc2My4wODggNDY5LjU5NUM3NjMuMDg4IDQ3OS43NTggNzYzLjA4OCA0ODkuOTIxIDc2My4wODggNTAwLjM5MkM3NTMuMjE3IDUwMC4zOTIgNzQzLjM0NiA1MDAuMzkyIDczMy4xNzYgNTAwLjM5MkM3MzMuMTc2IDUxMC41NTUgNzMzLjE3NiA1MjAuNzE4IDczMy4xNzYgNTMxLjE5QzcyMi43ODYgNTMxLjE5IDcxMi4zOTUgNTMxLjE5IDcwMS42OSA1MzEuMTlDNzAxLjY5IDU0MS4zNTMgNzAxLjY5IDU1MS41MTYgNzAxLjY5IDU2MS45ODdDNjkxLjgxOSA1NjEuOTg3IDY4MS45NDggNTYxLjk4NyA2NzEuNzc4IDU2MS45ODdDNjcxLjc3OCA1ODIuMDQ2IDY3MS43NzggNjAyLjEwNSA2NzEuNzc4IDYyMi43NzFDNjYyLjE2NyA2MjIuNzcxIDY1Mi41NTYgNjIyLjc3MSA2NDIuNjUzIDYyMi43NzFDNjQyLjY1MyA2MzIuNjY3IDY0Mi42NTMgNjQyLjU2MyA2NDIuNjUzIDY1Mi43NThDNjMyLjUyMyA2NTMuMDI2IDYyMi4zOTIgNjUzLjI5MyA2MTEuOTU0IDY1My41NjlDNjExLjY5NCA2NzQuNDMgNjExLjQzNSA2OTUuMjkxIDYxMS4xNjcgNzE2Ljc4NEM2MDEuMDM2IDcxNi43ODQgNTkwLjkwNiA3MTYuNzg0IDU4MC40NjggNzE2Ljc4NEM1ODAuNDc3IDcxOS4xNzUgNTgwLjQ4NiA3MjEuNTY1IDU4MC40OTYgNzI0LjAyOEM1ODAuNTAyIDcyNi40NDggNTgwLjUwNyA3MjguODY4IDU4MC41MTEgNzMxLjI4OEM1ODAuNTE1IDczMi45MTkgNTgwLjUyIDczNC41NSA1ODAuNTI3IDczNi4xODFDNTgwLjU4OCA3NTAuODE0IDU4MC4xMjUgNzY1LjM1NiA1NzkuNjgxIDc4MEM1NTguMzggNzgwIDUzNy4wOCA3ODAgNTE1LjEzNCA3ODBDNTE1LjEzNCA3NjkuNTY5IDUxNS4xMzQgNzU5LjEzOSA1MTUuMTM0IDc0OC4zOTJDNTA1LjI2MyA3NDguMzkyIDQ5NS4zOTIgNzQ4LjM5MiA0ODUuMjIyIDc0OC4zOTJDNDg1LjIyMiA3MzcuOTYyIDQ4NS4yMjIgNzI3LjUzMSA0ODUuMjIyIDcxNi43ODRDNDc1LjYxMSA3MTYuNzg0IDQ2NiA3MTYuNzg0IDQ1Ni4wOTcgNzE2Ljc4NEM0NTYuMDk3IDcwNi4zNTQgNDU2LjA5NyA2OTUuOTIzIDQ1Ni4wOTcgNjg1LjE3NkM0NDUuOTY3IDY4NS4xNzYgNDM1LjgzNiA2ODUuMTc2IDQyNS4zOTggNjg1LjE3NkM0MjUuMzk4IDY3NC43NDYgNDI1LjM5OCA2NjQuMzE1IDQyNS4zOTggNjUzLjU2OUM0MTUuMjY3IDY1My41NjkgNDA1LjEzNyA2NTMuNTY5IDM5NC42OTkgNjUzLjU2OUMzOTQuNjk5IDY0My40MDUgMzk0LjY5OSA2MzMuMjQyIDM5NC42OTkgNjIyLjc3MUMzODQuNTY4IDYyMi43NzEgMzc0LjQzOCA2MjIuNzcxIDM2NCA2MjIuNzcxQzM2NCA2MDIuNDQ1IDM2NCA1ODIuMTE5IDM2NCA1NjEuMTc2QzM4NC41MjEgNTYxLjE3NiA0MDUuMDQyIDU2MS4xNzYgNDI2LjE4NSA1NjEuMTc2QzQyNi4xODUgNTcxLjM0IDQyNi4xODUgNTgxLjUwMyA0MjYuMTg1IDU5MS45NzRDNDM2LjA1NiA1OTEuOTc0IDQ0NS45MjcgNTkxLjk3NCA0NTYuMDk3IDU5MS45NzRDNDU2LjA5NyA2MDIuMTM3IDQ1Ni4wOTcgNjEyLjMgNDU2LjA5NyA2MjIuNzcxQzQ2Ni4yMjggNjIyLjc3MSA0NzYuMzU5IDYyMi43NzEgNDg2Ljc5NiA2MjIuNzcxQzQ4Ni43OTYgNjMyLjY2NyA0ODYuNzk2IDY0Mi41NjMgNDg2Ljc5NiA2NTIuNzU4QzQ5Ni42NjcgNjUyLjc1OCA1MDYuNTM4IDY1Mi43NTggNTE2LjcwOCA2NTIuNzU4QzUxNi43MDggNjYzLjQ1NiA1MTYuNzA4IDY3NC4xNTQgNTE2LjcwOCA2ODUuMTc2QzUyNy4zNTggNjg1LjE3NiA1MzguMDA5IDY4NS4xNzYgNTQ4Ljk4MiA2ODUuMTc2QzU0OC45ODIgNjY0LjU4MyA1NDguOTgyIDY0My45ODkgNTQ4Ljk4MiA2MjIuNzcxQzU1OS4zNzIgNjIyLjc3MSA1NjkuNzYzIDYyMi43NzEgNTgwLjQ2OCA2MjIuNzcxQzU4MC40NjggNjAyLjQ0NSA1ODAuNDY4IDU4Mi4xMTkgNTgwLjQ2OCA1NjEuMTc2QzU5MC4zMzkgNTYxLjE3NiA2MDAuMjEgNTYxLjE3NiA2MTAuMzggNTYxLjE3NkM2MTAuMzggNTUxLjI4MSA2MTAuMzggNTQxLjM4NSA2MTAuMzggNTMxLjE5QzYyMC41MTEgNTMxLjE5IDYzMC42NDEgNTMxLjE5IDY0MS4wNzkgNTMxLjE5QzY0MS4wNzkgNTIwLjQ5MiA2NDEuMDc5IDUwOS43OTMgNjQxLjA3OSA0OTguNzcxQzY1MS4yMSA0OTguNzcxIDY2MS4zNCA0OTguNzcxIDY3MS43NzggNDk4Ljc3MUM2NzEuNzc4IDQ4OC44NzYgNjcxLjc3OCA0NzguOTggNjcxLjc3OCA0NjguNzg0QzY4MS45MDkgNDY4Ljc4NCA2OTIuMDM5IDQ2OC43ODQgNzAyLjQ3NyA0NjguNzg0QzcwMi40NzcgNDU4Ljg4OSA3MDIuNDc3IDQ0OC45OTMgNzAyLjQ3NyA0MzguNzk3QzcxMi4zNDggNDM4Ljc5NyA3MjIuMjE5IDQzOC43OTcgNzMyLjM4OSA0MzguNzk3QzczMi4zODkgNDI4LjYzNCA3MzIuMzg5IDQxOC40NzEgNzMyLjM4OSA0MDhaIiBmaWxsPSIjRkVGRUZFIi8+IDxwYXRoIGQ9Ik0yNzMuMTkzIDIyMUMzNDAuOTUzIDIyMSA0MDguNzE0IDIyMSA0NzguNTI3IDIyMUM0NzguNTI3IDIzMS40MTEgNDc4LjUyNyAyNDEuODIxIDQ3OC41MjcgMjUyLjU0N0M0ODguNjUyIDI1Mi41NDcgNDk4Ljc3NyAyNTIuNTQ3IDUwOS4yMDkgMjUyLjU0N0M1MDkuMjA5IDI2My4yMjUgNTA5LjIwOSAyNzMuOTAyIDUwOS4yMDkgMjg0LjkwM0M1MTkuMDc1IDI4NC45MDMgNTI4Ljk0IDI4NC45MDMgNTM5LjEwNSAyODQuOTAzQzUzOS4xMDUgMzA0LjY1NiA1MzkuMTA1IDMyNC40MSA1MzkuMTA1IDM0NC43NjJDNTQ4Ljk3IDM0NC43NjIgNTU4LjgzNiAzNDQuNzYyIDU2OSAzNDQuNzYyQzU2OSAzNjUuODUgNTY5IDM4Ni45MzggNTY5IDQwOC42NjVDNTU4Ljg3NSA0MDguNjY1IDU0OC43NSA0MDguNjY1IDUzOC4zMTggNDA4LjY2NUM1MzguMzE4IDM5OC4yNTQgNTM4LjMxOCAzODcuODQ0IDUzOC4zMTggMzc3LjExOEM1MjguNDUyIDM3Ny4xMTggNTE4LjU4NyAzNzcuMTE4IDUwOC40MjMgMzc3LjExOEM1MDguNDIzIDM2Ni43MDcgNTA4LjQyMyAzNTYuMjk3IDUwOC40MjMgMzQ1LjU3MUM0OTguMjk3IDM0NS41NzEgNDg4LjE3MiAzNDUuNTcxIDQ3Ny43NCAzNDUuNTcxQzQ3Ny43NCAzMzYuMjI4IDQ3Ny43NCAzMjYuODg1IDQ3Ny43NCAzMTcuMjU5QzQ3NC41MTcgMzE3LjI3MyA0NzQuNTE3IDMxNy4yNzMgNDcxLjIyOCAzMTcuMjg4QzQ2OS4xNTYgMzE3LjI5NCA0NjcuMDgzIDMxNy4yOTkgNDY1LjAxMSAzMTcuMzA0QzQ2My41NjYgMzE3LjMwOCA0NjIuMTIyIDMxNy4zMTMgNDYwLjY3NyAzMTcuMzJDNDU4LjYwNSAzMTcuMzMgNDU2LjUzMyAzMTcuMzM1IDQ1NC40NjIgMzE3LjMzOEM0NTMuNDg3IDMxNy4zNDQgNDUzLjQ4NyAzMTcuMzQ0IDQ1Mi40OTIgMzE3LjM1MUM0NTAuOTQzIDMxNy4zNTEgNDQ5LjM5NCAzMTcuMzA5IDQ0Ny44NDUgMzE3LjI1OUM0NDcuMDU4IDMxNi40NSA0NDcuMDU4IDMxNi40NSA0NDYuOTU0IDMxNC4zNzFDNDQ2Ljk3NCAzMDQuNzggNDQ2LjU0NyAyNjIuMTYyIDQ0Ni45NTQgMjUyLjU0N0MzOTguOTI1IDI1Mi41NDcgMzUxLjc4NyAyNTIuNTQ3IDMwMi4zMDIgMjUyLjU0N0MzMDIuMzAyIDI2Mi45NTggMzAyLjMwMiAzMDYuNTMzIDMwMi4zMDIgMzE3LjI1OUMyOTEuOTE3IDMxNy4yNTkgMjk0LjE5OSAzMTcuMjU5IDI4My41IDMxNy4yNTlDMjgzLjUgMzQ3LjE1NiAyODMuNSAzNzcuMDUzIDI4My41IDQwNy44NTZDMzAyLjk3MSA0MDcuODU2IDMwOS43NzYgNDA3Ljg1NiAzMjkuODM3IDQwNy44NTZDMzI5LjgzNyA0MTkuMDY3IDMyOS44MzcgNDU3Ljc4MSAzMjkuODM3IDQ2OS4zMzJDMzIwLjc1IDQ2OS4zMzIgMzExLjY2NCA0NjkuMzMyIDMwMi4zMDIgNDY5LjMzMkMzMDIuMzAyIDQ3OC40MDggMzAyLjMwMiA0OTAuNzIgMzAyLjMwMiA1MDAuMDcxQzI5Mi4xNzcgNTAwLjA3MSAyODIuMDUyIDUwMC4wNzEgMjcxLjYyIDUwMC4wNzFDMjcxLjYyIDUyMC4wOTEgMjcxLjYyIDUwOS4zNzMgMjcxLjYyIDUzMEMyNjEuMjM1IDUzMCAyNTAuODUgNTMwIDI0MC4xNTEgNTMwQzI0MC4xNTEgNTIwLjEyMyAyNDAuMTUxIDUxMC4yNDcgMjQwLjE1MSA1MDAuMDcxQzIzMC4wMjYgNTAwLjA3MSAyMTkuOTAxIDUwMC4wNzEgMjA5LjQ2OSA1MDAuMDcxQzIwOS40NjkgNDg5LjkyNyAyMDkuNDY5IDQ3OS43ODMgMjA5LjQ2OSA0NjkuMzMyQzE5OS4wODQgNDY5LjMzMiAxOTMuMTk5IDQ2OS4zMzIgMTgyLjUgNDY5LjMzMkMxODIuNSA0NDkuMDQ1IDE4Mi41IDQyOC43NTggMTgyLjUgNDA3Ljg1NkMxOTIuODg1IDQwNy44NTYgMjEwLjgwMSA0MDcuODU2IDIyMS41IDQwNy44NTZDMjIxLjUgMzY3LjI4MiAyMjEuNSAzNTkuMDYzIDIyMS41IDMxNy4yNTlDMjMxLjg4NSAzMTcuMjU5IDIzMC4yMzggMzE3LjI1OSAyNDAuOTM4IDMxNy4yNTlDMjQwLjkzOCAzMDYuNTgyIDI0MC45MzggMjYzLjU0OCAyNDAuOTM4IDI1Mi41NDdDMjUxLjU4MiAyNTIuNTQ3IDI2Mi4yMjYgMjUyLjU0NyAyNzMuMTkzIDI1Mi41NDdDMjczLjE5MyAyNDIuMTM3IDI3My4xOTMgMjMxLjcyNiAyNzMuMTkzIDIyMVoiIGZpbGw9IiNGRUZFRkUiLz4gPGRlZnM+IDxjbGlwUGF0aCBpZD0iY2xpcDBfNzA5XzMyIj4gPHJlY3Qgd2lkdGg9IjEwMDAiIGhlaWdodD0iMTAwMCIgZmlsbD0id2hpdGUiLz4gPC9jbGlwUGF0aD4gPC9kZWZzPiA8L3N2Zz4=";
const UNVERIFIED_PARTIAL_USER_SIGNATURE_CAP_IMAGE_URL: &str = "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxMDAwIiBoZWlnaHQ9IjEwMDAiIHZpZXdCb3g9IjAgMCAxMDAwIDEwMDAiIGZpbGw9Im5vbmUiPiA8ZyBjbGlwLXBhdGg9InVybCgjY2xpcDBfNzA0XzQ4KSI+IDxwYXRoIGQ9Ik0wIDBDMzMwIDAgNjYwIDAgMTAwMCAwQzEwMDAgMzMwIDEwMDAgNjYwIDEwMDAgMTAwMEM2NzAgMTAwMCAzNDAgMTAwMCAwIDEwMDBDMCA2NzAgMCAzNDAgMCAwWiIgZmlsbD0iI0VFMkI1QiIvPiA8cGF0aCBkPSJNNjgwIDY4MEM2OTMuMiA2ODAgNzA2LjQgNjgwIDcyMCA2ODBDNzIwIDY5My4yIDcyMCA3MDYuNCA3MjAgNzIwQzcwNi44IDcyMCA2OTMuNiA3MjAgNjgwIDcyMEM2ODAgNzA2LjggNjgwIDY5My42IDY4MCA2ODBaIiBmaWxsPSJ3aGl0ZSIvPiA8cGF0aCBkPSJNMjgwIDY4MEMyOTMuMiA2ODAgMzA2LjQgNjgwIDMyMCA2ODBDMzIwIDY5My4yIDMyMCA3MDYuNCAzMjAgNzIwQzMwNi44IDcyMCAyOTMuNiA3MjAgMjgwIDcyMEMyODAgNzA2LjggMjgwIDY5My42IDI4MCA2ODBaIiBmaWxsPSJ3aGl0ZSIvPiA8cGF0aCBkPSJNNjQwIDY0MEM2NTMuMiA2NDAgNjY2LjQgNjQwIDY4MCA2NDBDNjgwIDY1My4yIDY4MCA2NjYuNCA2ODAgNjgwQzY2Ni44IDY4MCA2NTMuNiA2ODAgNjQwIDY4MEM2NDAgNjY2LjggNjQwIDY1My42IDY0MCA2NDBaIiBmaWxsPSJ3aGl0ZSIvPiA8cGF0aCBkPSJNMzIwIDY0MEMzMzMuMiA2NDAgMzQ2LjQgNjQwIDM2MCA2NDBDMzYwIDY1My4yIDM2MCA2NjYuNCAzNjAgNjgwQzM0Ni44IDY4MCAzMzMuNiA2ODAgMzIwIDY4MEMzMjAgNjY2LjggMzIwIDY1My42IDMyMCA2NDBaIiBmaWxsPSJ3aGl0ZSIvPiA8cGF0aCBkPSJNNjAwIDYwMEM2MTMuMiA2MDAgNjI2LjQgNjAwIDY0MCA2MDBDNjQwIDYxMy4yIDY0MCA2MjYuNCA2NDAgNjQwQzYyNi44IDY0MCA2MTMuNiA2NDAgNjAwIDY0MEM2MDAgNjI2LjggNjAwIDYxMy42IDYwMCA2MDBaIiBmaWxsPSJ3aGl0ZSIvPiA8cGF0aCBkPSJNMzYwIDYwMEMzNzMuMiA2MDAgMzg2LjQgNjAwIDQwMCA2MDBDNDAwIDYxMy4yIDQwMCA2MjYuNCA0MDAgNjQwQzM4Ni44IDY0MCAzNzMuNiA2NDAgMzYwIDY0MEMzNjAgNjI2LjggMzYwIDYxMy42IDM2MCA2MDBaIiBmaWxsPSJ3aGl0ZSIvPiA8cGF0aCBkPSJNNTYwIDU2MEM1NzMuMiA1NjAgNTg2LjQgNTYwIDYwMCA1NjBDNjAwIDU3My4yIDYwMCA1ODYuNCA2MDAgNjAwQzU4Ni44IDYwMCA1NzMuNiA2MDAgNTYwIDYwMEM1NjAgNTg2LjggNTYwIDU3My42IDU2MCA1NjBaIiBmaWxsPSJ3aGl0ZSIvPiA8cGF0aCBkPSJNNDAwIDU2MEM0MTMuMiA1NjAgNDI2LjQgNTYwIDQ0MCA1NjBDNDQwIDU3My4yIDQ0MCA1ODYuNCA0NDAgNjAwQzQyNi44IDYwMCA0MTMuNiA2MDAgNDAwIDYwMEM0MDAgNTg2LjggNDAwIDU3My42IDQwMCA1NjBaIiBmaWxsPSJ3aGl0ZSIvPiA8cGF0aCBkPSJNNTIwIDUyMEM1MzMuMiA1MjAgNTQ2LjQgNTIwIDU2MCA1MjBDNTYwIDUzMy4yIDU2MCA1NDYuNCA1NjAgNTYwQzU0Ni44IDU2MCA1MzMuNiA1NjAgNTIwIDU2MEM1MjAgNTQ2LjggNTIwIDUzMy42IDUyMCA1MjBaIiBmaWxsPSJ3aGl0ZSIvPiA8cGF0aCBkPSJNNDQwIDUyMEM0NTMuMiA1MjAgNDY2LjQgNTIwIDQ4MCA1MjBDNDgwIDUzMy4yIDQ4MCA1NDYuNCA0ODAgNTYwQzQ2Ni44IDU2MCA0NTMuNiA1NjAgNDQwIDU2MEM0NDAgNTQ2LjggNDQwIDUzMy42IDQ0MCA1MjBaIiBmaWxsPSJ3aGl0ZSIvPiA8cGF0aCBkPSJNNDgwIDQ4MEM0OTMuMiA0ODAgNTA2LjQgNDgwIDUyMCA0ODBDNTIwIDQ5My4yIDUyMCA1MDYuNCA1MjAgNTIwQzUwNi44IDUyMCA0OTMuNiA1MjAgNDgwIDUyMEM0ODAgNTA2LjggNDgwIDQ5My42IDQ4MCA0ODBaIiBmaWxsPSJ3aGl0ZSIvPiA8cGF0aCBkPSJNNTIwIDQ0MEM1MzMuMiA0NDAgNTQ2LjQgNDQwIDU2MCA0NDBDNTYwIDQ1My4yIDU2MCA0NjYuNCA1NjAgNDgwQzU0Ni44IDQ4MCA1MzMuNiA0ODAgNTIwIDQ4MEM1MjAgNDY2LjggNTIwIDQ1My42IDUyMCA0NDBaIiBmaWxsPSJ3aGl0ZSIvPiA8cGF0aCBkPSJNNDQwIDQ0MEM0NTMuMiA0NDAgNDY2LjQgNDQwIDQ4MCA0NDBDNDgwIDQ1My4yIDQ4MCA0NjYuNCA0ODAgNDgwQzQ2Ni44IDQ4MCA0NTMuNiA0ODAgNDQwIDQ4MEM0NDAgNDY2LjggNDQwIDQ1My42IDQ0MCA0NDBaIiBmaWxsPSJ3aGl0ZSIvPiA8cGF0aCBkPSJNNTYwIDQwMEM1NzMuMiA0MDAgNTg2LjQgNDAwIDYwMCA0MDBDNjAwIDQxMy4yIDYwMCA0MjYuNCA2MDAgNDQwQzU4Ni44IDQ0MCA1NzMuNiA0NDAgNTYwIDQ0MEM1NjAgNDI2LjggNTYwIDQxMy42IDU2MCA0MDBaIiBmaWxsPSJ3aGl0ZSIvPiA8cGF0aCBkPSJNNDAwIDQwMEM0MTMuMiA0MDAgNDI2LjQgNDAwIDQ0MCA0MDBDNDQwIDQxMy4yIDQ0MCA0MjYuNCA0NDAgNDQwQzQyNi44IDQ0MCA0MTMuNiA0NDAgNDAwIDQ0MEM0MDAgNDI2LjggNDAwIDQxMy42IDQwMCA0MDBaIiBmaWxsPSJ3aGl0ZSIvPiA8cGF0aCBkPSJNNjAwIDM2MEM2MTMuMiAzNjAgNjI2LjQgMzYwIDY0MCAzNjBDNjQwIDM3My4yIDY0MCAzODYuNCA2NDAgNDAwQzYyNi44IDQwMCA2MTMuNiA0MDAgNjAwIDQwMEM2MDAgMzg2LjggNjAwIDM3My42IDYwMCAzNjBaIiBmaWxsPSJ3aGl0ZSIvPiA8cGF0aCBkPSJNMzYwIDM2MEMzNzMuMiAzNjAgMzg2LjQgMzYwIDQwMCAzNjBDNDAwIDM3My4yIDQwMCAzODYuNCA0MDAgNDAwQzM4Ni44IDQwMCAzNzMuNiA0MDAgMzYwIDQwMEMzNjAgMzg2LjggMzYwIDM3My42IDM2MCAzNjBaIiBmaWxsPSJ3aGl0ZSIvPiA8cGF0aCBkPSJNNjQwIDMyMEM2NTMuMiAzMjAgNjY2LjQgMzIwIDY4MCAzMjBDNjgwIDMzMy4yIDY4MCAzNDYuNCA2ODAgMzYwQzY2Ni44IDM2MCA2NTMuNiAzNjAgNjQwIDM2MEM2NDAgMzQ2LjggNjQwIDMzMy42IDY0MCAzMjBaIiBmaWxsPSJ3aGl0ZSIvPiA8cGF0aCBkPSJNMzIwIDMyMEMzMzMuMiAzMjAgMzQ2LjQgMzIwIDM2MCAzMjBDMzYwIDMzMy4yIDM2MCAzNDYuNCAzNjAgMzYwQzM0Ni44IDM2MCAzMzMuNiAzNjAgMzIwIDM2MEMzMjAgMzQ2LjggMzIwIDMzMy42IDMyMCAzMjBaIiBmaWxsPSJ3aGl0ZSIvPiA8cGF0aCBkPSJNNjgwIDI4MEM2OTMuMiAyODAgNzA2LjQgMjgwIDcyMCAyODBDNzIwIDI5My4yIDcyMCAzMDYuNCA3MjAgMzIwQzcwNi44IDMyMCA2OTMuNiAzMjAgNjgwIDMyMEM2ODAgMzA2LjggNjgwIDI5My42IDY4MCAyODBaIiBmaWxsPSJ3aGl0ZSIvPiA8cGF0aCBkPSJNMjgwIDI4MEMyOTMuMiAyODAgMzA2LjQgMjgwIDMyMCAyODBDMzIwIDI5My4yIDMyMCAzMDYuNCAzMjAgMzIwQzMwNi44IDMyMCAyOTMuNiAzMjAgMjgwIDMyMEMyODAgMzA2LjggMjgwIDI5My42IDI4MCAyODBaIiBmaWxsPSJ3aGl0ZSIvPiA8L2c+IDxkZWZzPiA8Y2xpcFBhdGggaWQ9ImNsaXAwXzcwNF80OCI+IDxyZWN0IHdpZHRoPSIxMDAwIiBoZWlnaHQ9IjEwMDAiIGZpbGw9IndoaXRlIi8+IDwvY2xpcFBhdGg+IDwvZGVmcz4gPC9zdmc+";
const VERIFIED_PARTIAL_USER_SIGNATURE_CAP_IMAGE_URL: &str = "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxMDAwIiBoZWlnaHQ9IjEwMDAiIHZpZXdCb3g9IjAgMCAxMDAwIDEwMDAiIGZpbGw9Im5vbmUiPiA8ZyBjbGlwLXBhdGg9InVybCgjY2xpcDBfNzA0XzM3KSI+IDxwYXRoIGQ9Ik0wIDBDMzMwIDAgNjYwIDAgMTAwMCAwQzEwMDAgMzMwIDEwMDAgNjYwIDEwMDAgMTAwMEM2NzAgMTAwMCAzNDAgMTAwMCAwIDEwMDBDMCA2NzAgMCAzNDAgMCAwWiIgZmlsbD0iI0VFMkI1QiIvPiA8cGF0aCBkPSJNMTIwIDM0MEMzNzAuOCAzNDAgNjIxLjYgMzQwIDg4MCAzNDBDODgwIDM1My4yIDg4MCAzNjYuNCA4ODAgMzgwQzg2Ni44IDM4MCA4NTMuNiAzODAgODQwIDM4MEM4NDAgMzkzLjIgODQwIDQwNi40IDg0MCA0MjBDODI2LjggNDIwIDgxMy42IDQyMCA4MDAgNDIwQzgwMCA0MzMuMiA4MDAgNDQ2LjQgODAwIDQ2MEM3ODYuOCA0NjAgNzczLjYgNDYwIDc2MCA0NjBDNzYwIDQ3My4yIDc2MCA0ODYuNCA3NjAgNTAwQzc0Ni44IDUwMCA3MzMuNiA1MDAgNzIwIDUwMEM3MjAgNTEzLjIgNzIwIDUyNi40IDcyMCA1NDBDNzA2LjggNTQwIDY5My42IDU0MCA2ODAgNTQwQzY4MCA1NTMuMiA2ODAgNTY2LjQgNjgwIDU4MEM2NjYuOCA1ODAgNjUzLjYgNTgwIDY0MCA1ODBDNjQwIDU5My4yIDY0MCA2MDYuNCA2NDAgNjIwQzYyNi44IDYyMCA2MTMuNiA2MjAgNjAwIDYyMEM2MDAgNjMzLjIgNjAwIDY0Ni40IDYwMCA2NjBDNTg2LjggNjYwIDU3My42IDY2MCA1NjAgNjYwQzU2MCA2NzMuMiA1NjAgNjg2LjQgNTYwIDcwMEM1NDYuOCA3MDAgNTMzLjYgNzAwIDUyMCA3MDBDNTIwIDcxMy4yIDUyMCA3MjYuNCA1MjAgNzQwQzUwNi44IDc0MCA0OTMuNiA3NDAgNDgwIDc0MEM0ODAgNzI2LjggNDgwIDcxMy42IDQ4MCA3MDBDNDY2LjggNzAwIDQ1My42IDcwMCA0NDAgNzAwQzQ0MCA2ODYuOCA0NDAgNjczLjYgNDQwIDY2MEM0MjYuOCA2NjAgNDEzLjYgNjYwIDQwMCA2NjBDNDAwIDY0Ni44IDQwMCA2MzMuNiA0MDAgNjIwQzM4Ni44IDYyMCAzNzMuNiA2MjAgMzYwIDYyMEMzNjAgNjA2LjggMzYwIDU5My42IDM2MCA1ODBDMzQ2LjggNTgwIDMzMy42IDU4MCAzMjAgNTgwQzMyMCA1NjYuOCAzMjAgNTUzLjYgMzIwIDU0MEMzMDYuOCA1NDAgMjkzLjYgNTQwIDI4MCA1NDBDMjgwIDUyNi44IDI4MCA1MTMuNiAyODAgNTAwQzI2Ni44IDUwMCAyNTMuNiA1MDAgMjQwIDUwMEMyNDAgNDg2LjggMjQwIDQ3My42IDI0MCA0NjBDMjI2LjggNDYwIDIxMy42IDQ2MCAyMDAgNDYwQzIwMCA0NDYuOCAyMDAgNDMzLjYgMjAwIDQyMEMxODYuOCA0MjAgMTczLjYgNDIwIDE2MCA0MjBDMTYwIDQwNi44IDE2MCAzOTMuNiAxNjAgMzgwQzE0Ni44IDM4MCAxMzMuNiAzODAgMTIwIDM4MEMxMjAgMzY2LjggMTIwIDM1My42IDEyMCAzNDBaIiBmaWxsPSJ3aGl0ZSIvPiA8cGF0aCBkPSJNNDgwIDU0MEM0OTMuMiA1NDAgNTA2LjQgNTQwIDUyMCA1NDBDNTIwIDU1My4yIDUyMCA1NjYuNCA1MjAgNTgwQzUzMy4yIDU4MCA1NDYuNCA1ODAgNTYwIDU4MEM1NjAgNTkzLjIgNTYwIDYwNi40IDU2MCA2MjBDNTczLjIgNjIwIDU4Ni40IDYyMCA2MDAgNjIwQzYwMCA2MzMuMiA2MDAgNjQ2LjQgNjAwIDY2MEM1ODYuOCA2NjAgNTczLjYgNjYwIDU2MCA2NjBDNTYwIDY3My4yIDU2MCA2ODYuNCA1NjAgNzAwQzU0Ni44IDcwMCA1MzMuNiA3MDAgNTIwIDcwMEM1MjAgNzEzLjIgNTIwIDcyNi40IDUyMCA3NDBDNTA2LjggNzQwIDQ5My42IDc0MCA0ODAgNzQwQzQ4MCA3MjYuOCA0ODAgNzEzLjYgNDgwIDcwMEM0NjYuOCA3MDAgNDUzLjYgNzAwIDQ0MCA3MDBDNDQwIDY4Ni44IDQ0MCA2NzMuNiA0NDAgNjYwQzQyNi44IDY2MCA0MTMuNiA2NjAgNDAwIDY2MEM0MDAgNjQ2LjggNDAwIDYzMy42IDQwMCA2MjBDNDEzLjIgNjIwIDQyNi40IDYyMCA0NDAgNjIwQzQ0MCA2MDYuOCA0NDAgNTkzLjYgNDQwIDU4MEM0NTMuMiA1ODAgNDY2LjQgNTgwIDQ4MCA1ODBDNDgwIDU2Ni44IDQ4MCA1NTMuNiA0ODAgNTQwWiIgZmlsbD0id2hpdGUiLz4gPHBhdGggZD0iTTU2MCA1ODBDNTczLjIgNTgwIDU4Ni40IDU4MCA2MDAgNTgwQzYwMCA1OTMuMiA2MDAgNjA2LjQgNjAwIDYyMEM1ODYuOCA2MjAgNTczLjYgNjIwIDU2MCA2MjBDNTYwIDYwNi44IDU2MCA1OTMuNiA1NjAgNTgwWiIgZmlsbD0iI0VFMkI1QiIvPiA8cGF0aCBkPSJNNDAwIDU4MEM0MTMuMiA1ODAgNDI2LjQgNTgwIDQ0MCA1ODBDNDQwIDU5My4yIDQ0MCA2MDYuNCA0NDAgNjIwQzQyNi44IDYyMCA0MTMuNiA2MjAgNDAwIDYyMEM0MDAgNjA2LjggNDAwIDU5My42IDQwMCA1ODBaIiBmaWxsPSIjRUUyQjVCIi8+IDxwYXRoIGQ9Ik01MjAgNTQwQzUzMy4yIDU0MCA1NDYuNCA1NDAgNTYwIDU0MEM1NjAgNTUzLjIgNTYwIDU2Ni40IDU2MCA1ODBDNTQ2LjggNTgwIDUzMy42IDU4MCA1MjAgNTgwQzUyMCA1NjYuOCA1MjAgNTUzLjYgNTIwIDU0MFoiIGZpbGw9IiNFRTJCNUIiLz4gPHBhdGggZD0iTTQ0MCA1NDBDNDUzLjIgNTQwIDQ2Ni40IDU0MCA0ODAgNTQwQzQ4MCA1NTMuMiA0ODAgNTY2LjQgNDgwIDU4MEM0NjYuOCA1ODAgNDUzLjYgNTgwIDQ0MCA1ODBDNDQwIDU2Ni44IDQ0MCA1NTMuNiA0NDAgNTQwWiIgZmlsbD0iI0VFMkI1QiIvPiA8cGF0aCBkPSJNNDgwIDUwMEM0OTMuMiA1MDAgNTA2LjQgNTAwIDUyMCA1MDBDNTIwIDUxMy4yIDUyMCA1MjYuNCA1MjAgNTQwQzUwNi44IDU0MCA0OTMuNiA1NDAgNDgwIDU0MEM0ODAgNTI2LjggNDgwIDUxMy42IDQ4MCA1MDBaIiBmaWxsPSIjRUUyQjVCIi8+IDwvZz4gPGRlZnM+IDxjbGlwUGF0aCBpZD0iY2xpcDBfNzA0XzM3Ij4gPHJlY3Qgd2lkdGg9IjEwMDAiIGhlaWdodD0iMTAwMCIgZmlsbD0id2hpdGUiLz4gPC9jbGlwUGF0aD4gPC9kZWZzPiA8L3N2Zz4=";

pub async fn init_ika_on_sui(
    validator_initialization_configs: &Vec<ValidatorInitializationConfig>,
    sui_fullnode_rpc_url: String,
    sui_faucet_url: String,
    initiation_parameters: InitiationParameters,
) -> Result<(ObjectID, ObjectID, ObjectID, SuiKeyPair), anyhow::Error> {
    //let config_dir = ika_config_dir()?;
    let config_dir = tempfile::tempdir()?.into_path();
    let config_path = config_dir.join(SUI_CLIENT_CONFIG);
    //let keystore_path = config_dir.join(SUI_KEYSTORE_FILENAME);
    //let mut keystore = Keystore::from(FileBasedKeystore::new(&keystore_path)?);
    let mut keystore = Keystore::InMem(InMemKeystore::default());
    let alias = "publisher";
    let _ = keystore.update_alias(alias, None);
    let (publisher_address, phrase, scheme) = keystore.generate_and_add_new_key(
        SignatureScheme::ED25519,
        Some(alias.to_string()),
        None,
        None,
    )?;

    let publisher_keypair = keystore.get_key(&publisher_address)?.copy();

    println!(
        "Generated new keypair and alias for address with scheme {:?} [{alias}: {publisher_address}]",
        scheme.to_string()
    );
    println!("Secret Recovery Phrase : [{phrase}]");
    let active_env = "localnet";
    SuiClientConfig {
        keystore,
        envs: vec![SuiEnv {
            alias: active_env.to_string(),
            rpc: sui_fullnode_rpc_url.clone(),
            ws: None,
            basic_auth: None,
        }],
        active_address: Some(publisher_address),
        active_env: Some(active_env.to_string()),
    }
    .persisted(&config_path)
    .save()?;

    let mut context = WalletContext::new(&config_path)?;

    let client = context.get_client().await?;

    let mut request_tokens_from_faucet_futures = vec![
        request_tokens_from_faucet(publisher_address, sui_faucet_url.clone()),
        request_tokens_from_faucet(publisher_address, sui_faucet_url.clone()),
    ];
    let mut validator_addresses = Vec::new();
    for validator_initialization_config in validator_initialization_configs {
        let alias = validator_initialization_config.name.clone().unwrap();
        context.add_account(
            Some(alias),
            validator_initialization_config.account_key_pair.copy(),
        );

        let validator_address: SuiAddress =
            (&validator_initialization_config.account_key_pair.public()).into();

        request_tokens_from_faucet_futures.push(request_tokens_from_faucet(
            validator_address,
            sui_faucet_url.clone(),
        ));

        validator_addresses.push(validator_address);
    }

    futures::future::join_all(request_tokens_from_faucet_futures)
        .await
        .into_iter()
        .collect::<Result<Vec<_>, _>>()
        // Temporary workaround for the faucet returning 200 OK, but it seems as an error
        // since the new faucet api changed
        // TODO: Remove this workaround when we move to the new sui version and new faucet api
        .or_else(|e| {
            if e.to_string().contains("200 OK") {
                Ok(vec![])
            } else {
                Err(e)
            }
        })?;

    let ika_package = ika_move_packages::BuiltInIkaMovePackages::get_package_by_name("ika");
    let ika_system_package =
        ika_move_packages::BuiltInIkaMovePackages::get_package_by_name("ika_system");

    let (ika_package_id, treasury_cap_id, ika_package_upgrade_cap_id) =
        publish_ika_package_to_sui(publisher_address, &mut context, client.clone(), ika_package)
            .await?;
    tokio::time::sleep(tokio::time::Duration::from_secs(2)).await;

    println!("Package `ika` published: ika_package_id: {ika_package_id} treasury_cap_id: {treasury_cap_id}");

    let (ika_system_package_id, init_cap_id, ika_system_package_upgrade_cap_id) =
        publish_ika_system_package_to_sui(
            publisher_address,
            &mut context,
            client.clone(),
            ika_system_package,
            ika_package_id,
        )
        .await?;

    println!("Package `ika_system` published: ika_system_package_id: {ika_system_package_id} init_cap_id: {init_cap_id}");

    let ika_supply_id = minted_ika(publisher_address, client.clone(), ika_package_id).await?;

    println!("Minting done: ika_supply_id: {ika_supply_id}");

    let (ika_system_object_id, protocol_cap_id, init_system_shared_version) = init_initialize(
        publisher_address,
        &mut context,
        client.clone(),
        ika_system_package_id,
        init_cap_id,
        ika_package_upgrade_cap_id,
        ika_system_package_upgrade_cap_id,
        treasury_cap_id,
        initiation_parameters.clone(),
    )
    .await?;

    println!("Running `init::initialize` done: ika_system_object_id: {ika_system_object_id} protocol_cap_id: {protocol_cap_id}");
    let ika_config = IkaPackagesConfig {
        ika_package_id,
        ika_system_package_id,
        ika_system_object_id,
    };
    let mut file = File::create("ika_config.json")?;
    let json = serde_json::to_string_pretty(&ika_config)?;
    file.write_all(json.as_bytes())?;

    let mut validator_ids = Vec::new();
    let mut validator_cap_ids = Vec::new();
    for validator_initialization_config in validator_initialization_configs {
        let validator_address: SuiAddress =
            (&validator_initialization_config.account_key_pair.public()).into();

        let validator_initialization_metadata = validator_initialization_config.to_validator_info();
        let (validator_id, validator_cap_id) = request_add_validator_candidate(
            validator_address,
            &mut context,
            client.clone(),
            &validator_initialization_metadata,
            ika_system_package_id,
            ika_system_object_id,
            init_system_shared_version,
        )
        .await?;
        validator_ids.push(validator_id);
        validator_cap_ids.push(validator_cap_id);
        println!("Running `system::request_add_validator_candidate` done for validator {validator_address}");
    }

    stake_ika(
        publisher_address,
        &mut context,
        ika_system_package_id,
        ika_system_object_id,
        init_system_shared_version,
        ika_supply_id,
        validator_ids.clone(),
    )
    .await?;

    println!("Staking for all validators done.");

    for (validator_address, validator_cap_id) in validator_addresses.iter().zip(validator_cap_ids) {
        request_add_validator(
            *validator_address,
            &mut context,
            client.clone(),
            ika_system_package_id,
            ika_system_object_id,
            init_system_shared_version,
            validator_cap_id,
        )
        .await?;
        println!("Running `system::request_add_validator` done for validator {validator_address}");
    }

    let (dwallet_2pc_mpc_coordinator_id, dwallet_2pc_mpc_coordinator_initial_shared_version) =
        ika_system_initialize(
            publisher_address,
            &mut context,
            client.clone(),
            ika_system_package_id,
            ika_system_object_id,
            init_system_shared_version,
            protocol_cap_id,
            initiation_parameters.max_validator_change_count,
        )
        .await?;
    println!("Running `system::initialize` done.");

    ika_system_request_dwallet_network_encryption_key_dkg_by_cap(
        publisher_address,
        &mut context,
        client.clone(),
        ika_system_package_id,
        ika_system_object_id,
        init_system_shared_version,
        dwallet_2pc_mpc_coordinator_id,
        dwallet_2pc_mpc_coordinator_initial_shared_version,
        protocol_cap_id,
    )
    .await?;

    println!("Running `system::request_dwallet_network_encryption_key_dkg_by_cap` done.");

    tokio::time::sleep(tokio::time::Duration::from_secs(2)).await;

    Ok((
        ika_package_id,
        ika_system_package_id,
        ika_system_object_id,
        publisher_keypair,
    ))
}

pub async fn ika_system_request_dwallet_network_encryption_key_dkg_by_cap(
    publisher_address: SuiAddress,
    context: &mut WalletContext,
    client: SuiClient,
    ika_system_package_id: ObjectID,
    ika_system_object_id: ObjectID,
    init_system_shared_version: SequenceNumber,
    dwallet_2pc_mpc_coordinator_id: ObjectID,
    dwallet_2pc_mpc_coordinator_initial_shared_version: SequenceNumber,
    protocol_cap_id: ObjectID,
) -> Result<(), anyhow::Error> {
    let mut ptb = ProgrammableTransactionBuilder::new();

    let protocol_cap_ref = client
        .transaction_builder()
        .get_object_ref(protocol_cap_id)
        .await?;

    ptb.move_call(
        ika_system_package_id,
        SYSTEM_MODULE_NAME.into(),
        REQUEST_DWALLET_NETWORK_DECRYPTION_KEY_DKG_BY_CAP_FUNCTION_NAME.into(),
        vec![],
        vec![
            CallArg::Object(ObjectArg::SharedObject {
                id: ika_system_object_id,
                initial_shared_version: init_system_shared_version,
                mutable: true,
            }),
            CallArg::Object(ObjectArg::SharedObject {
                id: dwallet_2pc_mpc_coordinator_id,
                initial_shared_version: dwallet_2pc_mpc_coordinator_initial_shared_version,
                mutable: true,
            }),
            CallArg::Object(ObjectArg::ImmOrOwnedObject(protocol_cap_ref)),
        ],
    )?;

    let tx_kind = TransactionKind::ProgrammableTransaction(ptb.finish());

    let _ = execute_sui_transaction(publisher_address, tx_kind, context, vec![]).await?;

    Ok(())
}

pub async fn ika_system_initialize(
    publisher_address: SuiAddress,
    context: &mut WalletContext,
    client: SuiClient,
    ika_system_package_id: ObjectID,
    ika_system_object_id: ObjectID,
    init_system_shared_version: SequenceNumber,
    protocol_cap_id: ObjectID,
    max_validator_change_count: u64,
) -> Result<(ObjectID, SequenceNumber), anyhow::Error> {
    let mut ptb = ProgrammableTransactionBuilder::new();

    let protocol_cap_ref = client
        .transaction_builder()
        .get_object_ref(protocol_cap_id)
        .await?;

    let zero_key = ptb.input(CallArg::Pure(bcs::to_bytes(&vec![0u32])?))?;
    let zero_and_one_value = ptb.input(CallArg::Pure(bcs::to_bytes(&vec![vec![0u32, 1u32]])?))?;
    let zero = ptb.input(CallArg::Pure(bcs::to_bytes(&0u32)?))?;
    let zero_option = ptb.input(CallArg::Pure(bcs::to_bytes(&Some(0u32))?))?;
    let none_option = ptb.input(CallArg::Pure(bcs::to_bytes(&None::<u32>)?))?;

    let dkg_first_round_protocol_flag = ptb.input(CallArg::Pure(bcs::to_bytes(
        &DKG_FIRST_ROUND_PROTOCOL_FLAG,
    )?))?;
    let dkg_second_round_protocol_flag = ptb.input(CallArg::Pure(bcs::to_bytes(
        &DKG_SECOND_ROUND_PROTOCOL_FLAG,
    )?))?;
    let re_encrypt_user_share_protocol_flag = ptb.input(CallArg::Pure(bcs::to_bytes(
        &RE_ENCRYPT_USER_SHARE_PROTOCOL_FLAG,
    )?))?;
    let make_dwallet_user_secret_key_share_public_protocol_flag = ptb.input(CallArg::Pure(
        bcs::to_bytes(&MAKE_DWALLET_USER_SECRET_KEY_SHARE_PUBLIC_PROTOCOL_FLAG)?,
    ))?;
    let imported_key_dwallet_verification_protocol_flag = ptb.input(CallArg::Pure(
        bcs::to_bytes(&IMPORTED_KEY_DWALLET_VERIFICATION_PROTOCOL_FLAG)?,
    ))?;
    let presign_protocol_flag = ptb.input(CallArg::Pure(bcs::to_bytes(&PRESIGN_PROTOCOL_FLAG)?))?;
    let sign_protocol_flag = ptb.input(CallArg::Pure(bcs::to_bytes(&SIGN_PROTOCOL_FLAG)?))?;
    let future_sign_protocol_flag =
        ptb.input(CallArg::Pure(bcs::to_bytes(&FUTURE_SIGN_PROTOCOL_FLAG)?))?;
    let sign_with_partial_user_signature_protocol_flag = ptb.input(CallArg::Pure(
        bcs::to_bytes(&SIGN_WITH_PARTIAL_USER_SIGNATURE_PROTOCOL_FLAG)?,
    ))?;

    let zero_price = ptb.input(CallArg::Pure(bcs::to_bytes(&0u64)?))?;

    let ika_system_arg = ptb.input(CallArg::Object(ObjectArg::SharedObject {
        id: ika_system_object_id,
        initial_shared_version: init_system_shared_version,
        mutable: true,
    }))?;

    let dwallet_pricing = ptb.programmable_move_call(
        ika_system_package_id,
        ident_str!("dwallet_pricing").into(),
        ident_str!("empty").into(),
        vec![],
        vec![],
    );

    ptb.programmable_move_call(
        ika_system_package_id,
        ident_str!("dwallet_pricing").into(),
        ident_str!("insert_or_update_dwallet_pricing").into(),
        vec![],
        vec![
            dwallet_pricing,
            zero,
            none_option,
            dkg_first_round_protocol_flag,
            zero_price,
            zero_price,
            zero_price,
            zero_price,
        ],
    );

    ptb.programmable_move_call(
        ika_system_package_id,
        ident_str!("dwallet_pricing").into(),
        ident_str!("insert_or_update_dwallet_pricing").into(),
        vec![],
        vec![
            dwallet_pricing,
            zero,
            none_option,
            dkg_second_round_protocol_flag,
            zero_price,
            zero_price,
            zero_price,
            zero_price,
        ],
    );

    ptb.programmable_move_call(
        ika_system_package_id,
        ident_str!("dwallet_pricing").into(),
        ident_str!("insert_or_update_dwallet_pricing").into(),
        vec![],
        vec![
            dwallet_pricing,
            zero,
            none_option,
            re_encrypt_user_share_protocol_flag,
            zero_price,
            zero_price,
            zero_price,
            zero_price,
        ],
    );

    ptb.programmable_move_call(
        ika_system_package_id,
        ident_str!("dwallet_pricing").into(),
        ident_str!("insert_or_update_dwallet_pricing").into(),
        vec![],
        vec![
            dwallet_pricing,
            zero,
            none_option,
            make_dwallet_user_secret_key_share_public_protocol_flag,
            zero_price,
            zero_price,
            zero_price,
            zero_price,
        ],
    );

    ptb.programmable_move_call(
        ika_system_package_id,
        ident_str!("dwallet_pricing").into(),
        ident_str!("insert_or_update_dwallet_pricing").into(),
        vec![],
        vec![
            dwallet_pricing,
            zero,
            none_option,
            imported_key_dwallet_verification_protocol_flag,
            zero_price,
            zero_price,
            zero_price,
            zero_price,
        ],
    );

    ptb.programmable_move_call(
        ika_system_package_id,
        ident_str!("dwallet_pricing").into(),
        ident_str!("insert_or_update_dwallet_pricing").into(),
        vec![],
        vec![
            dwallet_pricing,
            zero,
            zero_option,
            presign_protocol_flag,
            zero_price,
            zero_price,
            zero_price,
            zero_price,
        ],
    );

    ptb.programmable_move_call(
        ika_system_package_id,
        ident_str!("dwallet_pricing").into(),
        ident_str!("insert_or_update_dwallet_pricing").into(),
        vec![],
        vec![
            dwallet_pricing,
            zero,
            zero_option,
            sign_protocol_flag,
            zero_price,
            zero_price,
            zero_price,
            zero_price,
        ],
    );

    ptb.programmable_move_call(
        ika_system_package_id,
        ident_str!("dwallet_pricing").into(),
        ident_str!("insert_or_update_dwallet_pricing").into(),
        vec![],
        vec![
            dwallet_pricing,
            zero,
            zero_option,
            future_sign_protocol_flag,
            zero_price,
            zero_price,
            zero_price,
            zero_price,
        ],
    );

    ptb.programmable_move_call(
        ika_system_package_id,
        ident_str!("dwallet_pricing").into(),
        ident_str!("insert_or_update_dwallet_pricing").into(),
        vec![],
        vec![
            dwallet_pricing,
            zero,
            zero_option,
            sign_with_partial_user_signature_protocol_flag,
            zero_price,
            zero_price,
            zero_price,
            zero_price,
        ],
    );

    let supported_signature_algorithms_to_hash_schemes = ptb.programmable_move_call(
        SUI_FRAMEWORK_PACKAGE_ID,
        ident_str!("vec_map").into(),
        ident_str!("from_keys_values").into(),
        vec![TypeTag::U32, TypeTag::Vector(Box::new(TypeTag::U32))],
        vec![zero_key, zero_and_one_value],
    );

    let supported_signature_algorithms_to_hash_schemes_vec = ptb.programmable_move_call(
        MOVE_STDLIB_PACKAGE_ID,
        ident_str!("vector").into(),
        ident_str!("singleton").into(),
        vec![TypeTag::Struct(Box::new(StructTag {
            address: SUI_FRAMEWORK_PACKAGE_ID.into(),
            module: ident_str!("vec_map").into(),
            name: ident_str!("VecMap").into(),
            type_params: vec![TypeTag::U32, TypeTag::Vector(Box::new(TypeTag::U32))],
        }))],
        vec![supported_signature_algorithms_to_hash_schemes],
    );

    let supported_curves_to_signature_algorithms_to_hash_schemes = ptb.programmable_move_call(
        SUI_FRAMEWORK_PACKAGE_ID,
        ident_str!("vec_map").into(),
        ident_str!("from_keys_values").into(),
        vec![
            TypeTag::U32,
            TypeTag::Struct(Box::new(StructTag {
                address: SUI_FRAMEWORK_PACKAGE_ID.into(),
                module: ident_str!("vec_map").into(),
                name: ident_str!("VecMap").into(),
                type_params: vec![TypeTag::U32, TypeTag::Vector(Box::new(TypeTag::U32))],
            })),
        ],
        vec![zero_key, supported_signature_algorithms_to_hash_schemes_vec],
    );

    let protocol_cap_arg = ptb.input(CallArg::Object(ObjectArg::ImmOrOwnedObject(
        protocol_cap_ref,
    )))?;

    let clock_arg = ptb.input(CallArg::Object(ObjectArg::SharedObject {
        id: SUI_CLOCK_OBJECT_ID,
        initial_shared_version: SUI_CLOCK_OBJECT_SHARED_VERSION,
        mutable: false,
    }))?;

    let max_validator_change_count =
        ptb.input(CallArg::Pure(bcs::to_bytes(&max_validator_change_count)?))?;

    ptb.programmable_move_call(
        ika_system_package_id,
        SYSTEM_MODULE_NAME.into(),
        INITIALIZE_FUNCTION_NAME.into(),
        vec![],
        vec![
            ika_system_arg,
            dwallet_pricing,
            supported_curves_to_signature_algorithms_to_hash_schemes,
            max_validator_change_count,
            protocol_cap_arg,
            clock_arg,
        ],
    );

    let tx_kind = TransactionKind::ProgrammableTransaction(ptb.finish());

    let response = execute_sui_transaction(publisher_address, tx_kind, context, vec![]).await?;

    let object_changes = response.object_changes.unwrap();

    let dwallet_2pc_mpc_coordinator_type = StructTag {
        address: ika_system_package_id.into(),
        module: DWALLET_2PC_MPC_SECP256K1_MODULE_NAME.into(),
        name: DWALLET_COORDINATOR_STRUCT_NAME.into(),
        type_params: vec![],
    };

    let dwallet_2pc_mpc_coordinator_id = *object_changes
        .iter()
        .filter_map(|o| match o {
            ObjectChange::Created {
                object_id,
                object_type,
                ..
            } if dwallet_2pc_mpc_coordinator_type == *object_type => Some(*object_id),
            _ => None,
        })
        .collect::<Vec<_>>()
        .first()
        .unwrap();

    tokio::time::sleep(tokio::time::Duration::from_secs(1)).await;

    let response = client
        .read_api()
        .get_object_with_options(
            dwallet_2pc_mpc_coordinator_id,
            SuiObjectDataOptions::new().with_owner(),
        )
        .await?;

    let Some(Owner::Shared {
        initial_shared_version,
    }) = response.data.unwrap().owner
    else {
        return Err(anyhow::Error::msg("Owner does not exist"));
    };

    Ok((dwallet_2pc_mpc_coordinator_id, initial_shared_version))
}

pub async fn init_initialize(
    publisher_address: SuiAddress,
    context: &mut WalletContext,
    client: SuiClient,
    ika_system_package_id: ObjectID,
    init_cap_id: ObjectID,
    ika_package_upgrade_cap_id: ObjectID,
    ika_system_package_upgrade_cap_id: ObjectID,
    treasury_cap_id: ObjectID,
    initiation_parameters: InitiationParameters,
) -> Result<(ObjectID, ObjectID, SequenceNumber), anyhow::Error> {
    let mut ptb = ProgrammableTransactionBuilder::new();

    let init_cap_ref = client
        .transaction_builder()
        .get_object_ref(init_cap_id)
        .await?;
    let ika_package_upgrade_cap_ref = client
        .transaction_builder()
        .get_object_ref(ika_package_upgrade_cap_id)
        .await?;
    let ika_system_package_upgrade_cap_ref = client
        .transaction_builder()
        .get_object_ref(ika_system_package_upgrade_cap_id)
        .await?;
    let treasury_cap_ref = client
        .transaction_builder()
        .get_object_ref(treasury_cap_id)
        .await?;

    ptb.move_call(
        ika_system_package_id,
        INIT_MODULE_NAME.into(),
        INITIALIZE_FUNCTION_NAME.into(),
        vec![],
        vec![
            CallArg::Object(ObjectArg::ImmOrOwnedObject(init_cap_ref)),
            CallArg::Object(ObjectArg::ImmOrOwnedObject(ika_package_upgrade_cap_ref)),
            CallArg::Object(ObjectArg::ImmOrOwnedObject(
                ika_system_package_upgrade_cap_ref,
            )),
            CallArg::Object(ObjectArg::ImmOrOwnedObject(treasury_cap_ref)),
            CallArg::Pure(bcs::to_bytes(&initiation_parameters.protocol_version)?),
            CallArg::Pure(bcs::to_bytes(
                &initiation_parameters.chain_start_timestamp_ms,
            )?),
            CallArg::Pure(bcs::to_bytes(&initiation_parameters.epoch_duration_ms)?),
            CallArg::Pure(bcs::to_bytes(
                &initiation_parameters.stake_subsidy_start_epoch,
            )?),
            CallArg::Pure(bcs::to_bytes(&initiation_parameters.stake_subsidy_rate)?),
            CallArg::Pure(bcs::to_bytes(
                &initiation_parameters.stake_subsidy_period_length,
            )?),
            CallArg::Pure(bcs::to_bytes(&initiation_parameters.min_validator_count)?),
            CallArg::Pure(bcs::to_bytes(&initiation_parameters.max_validator_count)?),
            CallArg::Pure(bcs::to_bytes(
                &initiation_parameters.min_validator_joining_stake,
            )?),
            CallArg::Pure(bcs::to_bytes(&initiation_parameters.reward_slashing_rate)?),
            CallArg::Pure(bcs::to_bytes(STAKED_IKA_ICON_URL)?),
            CallArg::Pure(bcs::to_bytes(DWALLET_CAP_IMAGE_URL)?),
            CallArg::Pure(bcs::to_bytes(IMPORTED_KEY_DWALLET_CAP_IMAGE_URL)?),
            CallArg::Pure(bcs::to_bytes(UNVERIFIED_PRESIGN_CAP_IMAGE_URL)?),
            CallArg::Pure(bcs::to_bytes(VERIFIED_PRESIGN_CAP_IMAGE_URL)?),
            CallArg::Pure(bcs::to_bytes(
                UNVERIFIED_PARTIAL_USER_SIGNATURE_CAP_IMAGE_URL,
            )?),
            CallArg::Pure(bcs::to_bytes(
                VERIFIED_PARTIAL_USER_SIGNATURE_CAP_IMAGE_URL,
            )?),
        ],
    )?;

    ptb.transfer_arg(publisher_address, Argument::Result(0));

    let tx_kind = TransactionKind::ProgrammableTransaction(ptb.finish());

    let response = execute_sui_transaction(publisher_address, tx_kind, context, vec![]).await?;

    let object_changes = response.object_changes.unwrap();

    let ika_system_object_id = *object_changes
        .iter()
        .filter_map(|o| match o {
            ObjectChange::Created {
                object_id,
                object_type,
                ..
            } if System::type_(ika_system_package_id.into()) == *object_type => Some(*object_id),
            _ => None,
        })
        .collect::<Vec<_>>()
        .first()
        .unwrap();

    let protocol_cap_type = StructTag {
        address: ika_system_package_id.into(),
        module: PROTOCOL_CAP_MODULE_NAME.into(),
        name: PROTOCOL_CAP_STRUCT_NAME.into(),
        type_params: vec![],
    };

    let protocol_cap_id = *object_changes
        .iter()
        .filter_map(|o| match o {
            ObjectChange::Created {
                object_id,
                object_type,
                ..
            } if protocol_cap_type == *object_type => Some(*object_id),
            _ => None,
        })
        .collect::<Vec<_>>()
        .first()
        .unwrap();

    tokio::time::sleep(tokio::time::Duration::from_secs(1)).await;

    let response = client
        .read_api()
        .get_object_with_options(
            ika_system_object_id,
            SuiObjectDataOptions::new().with_owner(),
        )
        .await?;

    let Some(Owner::Shared {
        initial_shared_version,
    }) = response.data.unwrap().owner
    else {
        return Err(anyhow::Error::msg("Owner does not exist"));
    };

    Ok((
        ika_system_object_id,
        protocol_cap_id,
        initial_shared_version,
    ))
}

async fn request_add_validator(
    validator_address: SuiAddress,
    context: &mut WalletContext,
    client: SuiClient,
    ika_system_package_id: ObjectID,
    ika_system_object_id: ObjectID,
    init_system_shared_version: SequenceNumber,
    validator_cap_id: ObjectID,
) -> Result<(), anyhow::Error> {
    let mut ptb = ProgrammableTransactionBuilder::new();

    let validator_cap_ref = client
        .transaction_builder()
        .get_object_ref(validator_cap_id)
        .await?;

    ptb.move_call(
        ika_system_package_id,
        SYSTEM_MODULE_NAME.into(),
        REQUEST_ADD_VALIDATOR_FUNCTION_NAME.into(),
        vec![],
        vec![
            CallArg::Object(ObjectArg::SharedObject {
                id: ika_system_object_id,
                initial_shared_version: init_system_shared_version,
                mutable: true,
            }),
            CallArg::Object(ObjectArg::ImmOrOwnedObject(validator_cap_ref)),
        ],
    )?;

    let tx_kind = TransactionKind::ProgrammableTransaction(ptb.finish());

    let _ = execute_sui_transaction(validator_address, tx_kind, context, vec![]).await?;

    Ok(())
}

async fn stake_ika(
    publisher_address: SuiAddress,
    context: &mut WalletContext,
    ika_system_package_id: ObjectID,
    ika_system_object_id: ObjectID,
    init_system_shared_version: SequenceNumber,
    ika_supply_id: ObjectID,
    validator_ids: Vec<ObjectID>,
) -> Result<(), anyhow::Error> {
    let mut ptb = ProgrammableTransactionBuilder::new();

    let init_arg = ptb.input(CallArg::Object(ObjectArg::SharedObject {
        id: ika_system_object_id,
        initial_shared_version: init_system_shared_version,
        mutable: true,
    }))?;

    let client = context.get_client().await?;

    let ika_supply_ref = client
        .transaction_builder()
        .get_object_ref(ika_supply_id)
        .await?;

    let ika_supply_id_arg =
        ptb.input(CallArg::Object(ObjectArg::ImmOrOwnedObject(ika_supply_ref)))?;
    let stake_amount = ptb.input(CallArg::Pure(bcs::to_bytes(
        &MIN_VALIDATOR_JOINING_STAKE_INKU,
    )?))?;

    for validator_id in validator_ids {
        let stake = ptb.command(sui_types::transaction::Command::SplitCoins(
            ika_supply_id_arg,
            vec![stake_amount],
        ));
        let validator = ptb.input(CallArg::Pure(bcs::to_bytes(&validator_id).unwrap()))?;

        let staked = ptb.command(sui_types::transaction::Command::move_call(
            ika_system_package_id,
            SYSTEM_MODULE_NAME.into(),
            REQUEST_ADD_STAKE_FUNCTION_NAME.into(),
            vec![],
            vec![init_arg, stake, validator],
        ));

        ptb.transfer_arg(publisher_address, staked);
    }

    let tx_kind = TransactionKind::ProgrammableTransaction(ptb.finish());

    let _ = execute_sui_transaction(publisher_address, tx_kind, context, vec![]).await?;

    Ok(())
}

pub async fn minted_ika(
    publisher_address: SuiAddress,
    client: SuiClient,
    ika_package_id: ObjectID,
) -> Result<ObjectID, anyhow::Error> {
    let data = client
        .read_api()
        .get_owned_objects(
            publisher_address,
            Some(SuiObjectResponseQuery {
                filter: Some(SuiObjectDataFilter::StructType(IKACoin::type_(
                    ika_package_id.into(),
                ))),
                options: None,
            }),
            None,
            None,
        )
        .await?;

    let ika_supply_id = &data.data.first().unwrap().object_id()?;

    Ok(*ika_supply_id)
}

async fn request_add_validator_candidate(
    validator_address: SuiAddress,
    context: &mut WalletContext,
    client: SuiClient,
    validator_initialization_metadata: &ValidatorInfo,
    ika_system_package_id: ObjectID,
    ika_system_object_id: ObjectID,
    init_system_shared_version: SequenceNumber,
) -> Result<(ObjectID, ObjectID), anyhow::Error> {
    let mut ptb = ProgrammableTransactionBuilder::new();

    let class_groups_pubkey_and_proof_obj_ref = create_class_groups_public_key_and_proof_object(
        validator_address,
        context,
        &client,
        ika_system_package_id,
        validator_initialization_metadata
            .class_groups_public_key_and_proof
            .clone(),
    )
    .await?;

    let name = ptb.input(CallArg::Pure(bcs::to_bytes(
        validator_initialization_metadata.name.as_str(),
    )?))?;
    let empty_str = ptb.input(CallArg::Pure(bcs::to_bytes(String::new().as_str())?))?;

    let system_ref = ptb.input(CallArg::Object(ObjectArg::SharedObject {
        id: ika_system_object_id,
        initial_shared_version: init_system_shared_version,
        mutable: true,
    }))?;

    let protocol_public_key = ptb.input(CallArg::Pure(bcs::to_bytes(
        &validator_initialization_metadata
            .protocol_public_key
            .as_bytes()
            .to_vec(),
    )?))?;

    let network_public_key = ptb.input(CallArg::Pure(bcs::to_bytes(
        &validator_initialization_metadata
            .network_public_key
            .as_bytes()
            .to_vec(),
    )?))?;

    let consensus_public_key = ptb.input(CallArg::Pure(bcs::to_bytes(
        &validator_initialization_metadata
            .consensus_public_key
            .as_bytes()
            .to_vec(),
    )?))?;

    let class_groups_pubkey_and_proof_obj_ref = ptb.input(CallArg::Object(
        ObjectArg::ImmOrOwnedObject(class_groups_pubkey_and_proof_obj_ref),
    ))?;

    let proof_of_possession = ptb.input(CallArg::Pure(bcs::to_bytes(
        &validator_initialization_metadata
            .proof_of_possession
            .as_ref()
            .to_vec(),
    )?))?;

    let network_address = ptb.input(CallArg::Pure(bcs::to_bytes(
        &validator_initialization_metadata.network_address.clone(),
    )?))?;

    let p2p_address = ptb.input(CallArg::Pure(bcs::to_bytes(
        &validator_initialization_metadata.p2p_address.clone(),
    )?))?;

    let consensus_address = ptb.input(CallArg::Pure(bcs::to_bytes(
        &validator_initialization_metadata.consensus_address.clone(),
    )?))?;

    let commission_rate = ptb.input(CallArg::Pure(bcs::to_bytes(
        &validator_initialization_metadata.commission_rate,
    )?))?;

    let metadata = ptb.command(Command::move_call(
        ika_system_package_id,
        VALIDATOR_METADATA_MODULE_NAME.into(),
        NEW_VALIDATOR_METADATA_FUNCTION_NAME.into(),
        vec![],
        vec![name, empty_str, empty_str],
    ));

    ptb.command(Command::move_call(
        ika_system_package_id,
        SYSTEM_MODULE_NAME.into(),
        REQUEST_ADD_VALIDATOR_CANDIDATE_FUNCTION_NAME.into(),
        vec![],
        vec![
            system_ref,
            name,
            protocol_public_key,
            network_public_key,
            consensus_public_key,
            class_groups_pubkey_and_proof_obj_ref,
            proof_of_possession,
            network_address,
            p2p_address,
            consensus_address,
            commission_rate,
            metadata,
        ],
    ));

    ptb.transfer_args(
        validator_address,
        vec![
            Argument::NestedResult(1, 0),
            Argument::NestedResult(1, 1),
            Argument::NestedResult(1, 2),
        ],
    );

    let tx_kind = TransactionKind::ProgrammableTransaction(ptb.finish());

    let response = execute_sui_transaction(validator_address, tx_kind, context, vec![]).await?;

    let object_changes = response.object_changes.unwrap();

    let validator_cap_type = StructTag {
        address: ika_system_package_id.into(),
        module: VALIDATOR_CAP_MODULE_NAME.into(),
        name: VALIDATOR_CAP_STRUCT_NAME.into(),
        type_params: vec![],
    };

    let validator_cap_id = *object_changes
        .iter()
        .filter_map(|o| match o {
            ObjectChange::Created {
                object_id,
                object_type,
                ..
            } if validator_cap_type == *object_type => Some(*object_id),
            _ => None,
        })
        .collect::<Vec<_>>()
        .first()
        .unwrap();

    let validator_cap = context
        .get_client()
        .await?
        .read_api()
        .get_move_object_bcs(validator_cap_id)
        .await?;
    let validator_cap: ValidatorCapV1 = bcs::from_bytes(&validator_cap)?;

    Ok((validator_cap.validator_id, validator_cap_id))
}

pub async fn publish_ika_system_package_to_sui(
    publisher_address: SuiAddress,
    context: &mut WalletContext,
    client: SuiClient,
    ika_system_package: &IkaMovePackage,
    ika_package_id: ObjectID,
) -> Result<(ObjectID, ObjectID, ObjectID), anyhow::Error> {
    let mut ika_system_package_dependencies = ika_system_package.dependencies.clone();
    ika_system_package_dependencies.push(ika_package_id);

    let bytes =
        ika_system_package.bytes_with_deps(HashMap::from([("ika".to_string(), ika_package_id)]))?;

    let object_changes = publish_package_to_sui(
        publisher_address,
        context,
        client,
        bytes,
        ika_system_package_dependencies,
    )
    .await?;
    let ika_system_package_id = *object_changes
        .iter()
        .filter_map(|o| match o {
            ObjectChange::Published { package_id, .. } => Some(*package_id),
            _ => None,
        })
        .collect::<Vec<_>>()
        .first()
        .unwrap();

    let init_cap_type = StructTag {
        address: ika_system_package_id.into(),
        module: INIT_MODULE_NAME.into(),
        name: INIT_CAP_STRUCT_NAME.into(),
        type_params: vec![],
    };

    let init_cap_id = *object_changes
        .iter()
        .filter_map(|o| match o {
            ObjectChange::Created {
                object_id,
                object_type,
                ..
            } if init_cap_type == *object_type => Some(*object_id),
            _ => None,
        })
        .collect::<Vec<_>>()
        .first()
        .unwrap();

    let ika_system_package_upgrade_cap_id = *object_changes
        .iter()
        .filter_map(|o| match o {
            ObjectChange::Created {
                object_id,
                object_type,
                ..
            } if UpgradeCap::type_() == *object_type => Some(*object_id),
            _ => None,
        })
        .collect::<Vec<_>>()
        .first()
        .unwrap();

    Ok((
        ika_system_package_id,
        init_cap_id,
        ika_system_package_upgrade_cap_id,
    ))
}

async fn create_class_groups_public_key_and_proof_builder_object(
    publisher_address: SuiAddress,
    context: &mut WalletContext,
    client: &SuiClient,
    ika_system_package_id: ObjectID,
) -> anyhow::Result<ObjectRef> {
    let mut ptb = ProgrammableTransactionBuilder::new();
    ptb.move_call(
        ika_system_package_id,
        CLASS_GROUPS_PUBLIC_KEY_AND_PROOF_MODULE_NAME.into(),
        CREATE_CLASS_GROUPS_PUBLIC_KEY_AND_PROOF_BUILDER_FUNCTION_NAME.into(),
        vec![],
        vec![],
    )?;
    ptb.transfer_arg(publisher_address, Argument::Result(0));
    let tx_kind = TransactionKind::ProgrammableTransaction(ptb.finish());

    let response = execute_sui_transaction(publisher_address, tx_kind, context, vec![]).await?;

    let object_changes = response.object_changes.unwrap();

    let builder_id = *object_changes
        .iter()
        .filter_map(|o| match o {
            ObjectChange::Created {
                object_id,
                object_type,
                ..
            } if ClassGroupsPublicKeyAndProofBuilder::type_(ika_system_package_id.into())
                == *object_type =>
            {
                Some(*object_id)
            }
            _ => None,
        })
        .collect::<Vec<_>>()
        .first()
        .unwrap();

    let builder_ref = client
        .transaction_builder()
        .get_object_ref(builder_id)
        .await?;

    Ok(builder_ref)
}

async fn create_class_groups_public_key_and_proof_object(
    publisher_address: SuiAddress,
    context: &mut WalletContext,
    client: &SuiClient,
    ika_system_package_id: ObjectID,
    class_groups_public_key_and_proof_bytes: Vec<u8>,
) -> anyhow::Result<ObjectRef> {
    let builder_object_ref = create_class_groups_public_key_and_proof_builder_object(
        publisher_address,
        context,
        client,
        ika_system_package_id,
    )
    .await?;

    let class_groups_public_key_and_proof: Box<ClassGroupsEncryptionKeyAndProof> =
        Box::new(bcs::from_bytes(&class_groups_public_key_and_proof_bytes)?);

    add_public_keys_and_proofs_with_rng(
        publisher_address,
        context,
        client,
        ika_system_package_id,
        (0, 3),
        builder_object_ref.0,
        &class_groups_public_key_and_proof,
    )
    .await?;
    let builder_object_ref = client
        .transaction_builder()
        .get_object_ref(builder_object_ref.0)
        .await?;
    let mut ptb = ProgrammableTransactionBuilder::new();
    ptb.move_call(
        ika_system_package_id,
        CLASS_GROUPS_PUBLIC_KEY_AND_PROOF_MODULE_NAME.into(),
        FINISH_CLASS_GROUPS_PUBLIC_KEY_AND_PROOF_FUNCTION_NAME.into(),
        vec![],
        vec![CallArg::Object(ObjectArg::ImmOrOwnedObject(
            builder_object_ref,
        ))],
    )?;
    ptb.transfer_arg(publisher_address, Argument::Result(0));
    let tx_kind = TransactionKind::ProgrammableTransaction(ptb.finish());

    let response = execute_sui_transaction(publisher_address, tx_kind, context, vec![]).await?;

    let object_changes = response
        .object_changes
        .ok_or(anyhow::Error::msg("Failed to get object changes"))?;

    let obj_id = *object_changes
        .iter()
        .filter_map(|o| match o {
            ObjectChange::Created {
                object_id,
                object_type,
                ..
            } if ClassGroupsPublicKeyAndProof::type_(ika_system_package_id.into())
                == *object_type =>
            {
                Some(*object_id)
            }
            _ => None,
        })
        .collect::<Vec<_>>()
        .first()
        .unwrap();

    let pubkey_and_proof_obj_ref = client.transaction_builder().get_object_ref(obj_id).await?;

    Ok(pubkey_and_proof_obj_ref)
}

async fn add_public_keys_and_proofs_with_rng(
    publisher_address: SuiAddress,
    context: &mut WalletContext,
    client: &SuiClient,
    ika_system_package_id: ObjectID,
    range: (u8, u8),
    cg_builder_object_id: ObjectID,
    class_groups_public_key_and_proof: &ClassGroupsEncryptionKeyAndProof,
) -> anyhow::Result<()> {
    let mut first_ptb = ProgrammableTransactionBuilder::new();
    let builder_object_ref = client
        .transaction_builder()
        .get_object_ref(cg_builder_object_id)
        .await?;
    for i in range.0..range.1 {
        let pubkey_and_proof = bcs::to_bytes(&class_groups_public_key_and_proof[i as usize])?;
        let proof_builder = first_ptb.obj(ObjectArg::ImmOrOwnedObject(builder_object_ref))?;
        let first_proof_bytes_half = first_ptb.pure(pubkey_and_proof[0..10_000].to_vec())?;
        let second_proof_bytes_half = first_ptb.pure(pubkey_and_proof[10_000..].to_vec())?;
        first_ptb.programmable_move_call(
            ika_system_package_id,
            CLASS_GROUPS_PUBLIC_KEY_AND_PROOF_MODULE_NAME.into(),
            ADD_PAIR_TO_CLASS_GROUPS_PUBLIC_KEY_AND_PROOF_FUNCTION_NAME.into(),
            vec![],
            vec![
                proof_builder,
                // Sui limits the size of a single call argument to 16KB.
                first_proof_bytes_half,
                second_proof_bytes_half,
            ],
        );
    }
    let tx_kind = TransactionKind::ProgrammableTransaction(first_ptb.finish());
    execute_sui_transaction(publisher_address, tx_kind, context, vec![]).await?;
    Ok(())
}

pub async fn publish_ika_package_to_sui(
    publisher_address: SuiAddress,
    context: &mut WalletContext,
    client: SuiClient,
    ika_package: &IkaMovePackage,
) -> Result<(ObjectID, ObjectID, ObjectID), anyhow::Error> {
    let object_changes = publish_package_to_sui(
        publisher_address,
        context,
        client,
        ika_package.bytes.clone(),
        ika_package.dependencies.clone(),
    )
    .await?;
    let ika_package_id = *object_changes
        .iter()
        .filter_map(|o| match o {
            ObjectChange::Published { package_id, .. } => Some(*package_id),
            _ => None,
        })
        .collect::<Vec<_>>()
        .first()
        .unwrap();

    let treasury_cap_id = *object_changes
        .iter()
        .filter_map(|o| match o {
            ObjectChange::Created {
                object_id,
                object_type,
                ..
            } if TreasuryCap::is_treasury_type(object_type) => Some(*object_id),
            _ => None,
        })
        .collect::<Vec<_>>()
        .first()
        .unwrap();

    let ika_package_upgrade_cap_id = *object_changes
        .iter()
        .filter_map(|o| match o {
            ObjectChange::Created {
                object_id,
                object_type,
                ..
            } if UpgradeCap::type_() == *object_type => Some(*object_id),
            _ => None,
        })
        .collect::<Vec<_>>()
        .first()
        .unwrap();

    Ok((ika_package_id, treasury_cap_id, ika_package_upgrade_cap_id))
}

async fn publish_package_to_sui(
    publisher_address: SuiAddress,
    context: &mut WalletContext,
    client: SuiClient,
    ika_move_package_bytes: Vec<Vec<u8>>,
    ika_move_package_dep_ids: Vec<ObjectID>,
) -> Result<Vec<ObjectChange>, anyhow::Error> {
    let tx_kind = client
        .transaction_builder()
        .publish_tx_kind(
            publisher_address,
            ika_move_package_bytes,
            ika_move_package_dep_ids,
        )
        .await?;

    let response = execute_sui_transaction(publisher_address, tx_kind, context, vec![]).await?;

    let object_changes = response.object_changes.unwrap();
    Ok(object_changes)
}

pub(crate) async fn create_sui_transaction(
    signer: SuiAddress,
    tx_kind: TransactionKind,
    context: &mut WalletContext,
    gas_payment: Vec<ObjectID>,
) -> Result<Transaction, anyhow::Error> {
    let gas_price = context.get_reference_gas_price().await?;

    let client = context.get_client().await?;

    //let gas_budget = max_gas_budget(&client).await?;
    let gas_budget =
        estimate_gas_budget(context, signer, tx_kind.clone(), gas_price, None, None).await?;

    let tx_data = client
        .transaction_builder()
        .tx_data(signer, tx_kind, gas_budget, gas_price, gas_payment, None)
        .await?;

    let signature = context.config.keystore.sign_secure(
        &tx_data.sender(),
        &tx_data,
        Intent::sui_transaction(),
    )?;
    let sender_signed_data = SenderSignedData::new_from_sender_signature(tx_data, signature);

    let transaction = Transaction::new(sender_signed_data);

    Ok(transaction)
}

pub(crate) async fn execute_sui_transaction(
    signer: SuiAddress,
    tx_kind: TransactionKind,
    context: &mut WalletContext,
    gas_payment: Vec<ObjectID>,
) -> Result<SuiTransactionBlockResponse, anyhow::Error> {
    let transaction = create_sui_transaction(signer, tx_kind, context, gas_payment).await?;

    let response = context
        .execute_transaction_may_fail(transaction.clone())
        .await?;
    Ok(response)
}

pub async fn estimate_gas_budget(
    context: &mut WalletContext,
    signer: SuiAddress,
    kind: TransactionKind,
    gas_price: u64,
    gas_payment: Option<Vec<ObjectID>>,
    sponsor: Option<SuiAddress>,
) -> Result<u64, anyhow::Error> {
    let client = context.get_client().await?;
    let SuiClientCommandResult::DryRun(dry_run) =
        execute_dry_run(context, signer, kind, None, gas_price, gas_payment, sponsor).await?
    else {
        bail!("Wrong SuiClientCommandResult. Should be SuiClientCommandResult::DryRun.")
    };

    let rgp = client.read_api().get_reference_gas_price().await?;

    Ok(estimate_gas_budget_from_gas_cost(
        dry_run.effects.gas_cost_summary(),
        rgp,
    ))
}
