---
title: Use a dWallet on Ethereum
---

After [creating a dWallet](../your-first-dwallet.md#create-a-dwallet) we can derive the dWallet's Ethereum address, create transactions from that address, sign them with the dWallet, and broadcast the signed transactions to the Ethereum network.

## Setup
First, we must setup the environment. Begin by importing necessary functions:
```typescript
import {DWalletClient} from '@dwallet-network/dwallet.js/client';
import {Ed25519Keypair} from '@dwallet-network/dwallet.js/keypairs/ed25519';
import {requestSuiFromFaucetV0 as requestDwltFromFaucetV0} from '@dwallet-network/dwallet.js/faucet';
import {ethers} from "ethers";

var elliptic = require('elliptic');

import {
    createDWallet,
    createSignMessages,
    approveAndSign,
    submitDWalletCreationProof,
    submitTxStateProof,
    recoveryIdKeccak256,
} from '@dwallet-network/dwallet.js/signature-mpc';
```

## Get the dWallet's Ethereum address

To create transactions in the Ethereum network we need an Ethereum address.
Ethereum address is generated by hashing your public key in `sha3` format and taking the last 40 bytes of the result.

```typescript
// get the dWallet object
const dwallet = await dwalletClient.getObject({ id: dwalletId, options: {showContent: true}});
if (dwallet?.data?.content?.dataType == 'moveObject') {
    // Get the public key
    // @ts-ignore
    const pubkeyhex = Buffer.from(dwallet?.data?.content?.fields['public_key']).toString('hex');

    // The public key is in its compressed form so we uncompress it, as the address is derived from the uncompressed public key.
    var ec = new elliptic.ec('secp256k1');
    var publicKeyUncompressed = ec.keyFromPublic(pubkeyhex, 'hex').getPublic(false, 'hex');
    
    let pubkey = Buffer.from(publicKeyUncompressed, 'hex');

    // Here we are doing keccak256 hashing of our ECDSA public key
    const ethereumAddress = ethers.getAddress(ethers.keccak256(pubkey).slice(-40));

    console.log("dWallet Ethereum address is", ethereumAddress);
```

## Access the Ethereum network
We need a service which offers a web API for accessing the Ethereum Blockchain. These Providers allow connecting to them, which simplifies development.
In the following example we use `EtherscanProvider` with the Sepolia network which is Ethereum's proof-of-authority testnet.

```typescript
    const provider = new ethers.EtherscanProvider(ethers.Network.from("sepolia"), "");
    
    // Get chainId from network
    const chainId = (await provider.getNetwork()).chainId;
```

## Sign a Tx

You can create transactions using the [`ethers` library documentation on Transactions](https://docs.ethers.org/v5/api/providers/types/#types--transactions).
Once we have the transaction object, we sign the bytes of the hash generated from the transaction.

```typescript
    const tx = new ethers.Transaction()
    // * fill the tx parameters here *
    
    // `tx.unsignedSerialized` is a hex string starting with `0x`, so we remove it by slicing the first two characters before parsing it as a hex string into a byte array.
    const bytes = Uint8Array.from(Buffer.from(tx.unsignedSerialized.slice(2), 'hex'));
    
    // Sign the transaction bytes
    const signMessagesIdKECCAK256 = await createSignMessages(dkg?.dwalletId!, dkg?.dkgOutput, [bytes], "KECCAK256", keypair, dwalletClient);
    const sigKECCAK256 = await approveAndSign(dkg?.dwalletCapId!, signMessagesIdKECCAK256!, [bytes], keypair, dwalletClient);
    const sig = Buffer.from(sigKECCAK256?.signatures[0]).toString('hex');

    // @ts-ignore
    const recoveryId = "0" + recoveryIdKeccak256(dwallet?.data?.content?.fields['public_key'], bytes, sigKECCAK256?.signatures[0]).toString(16);
    
    // Serialized signature in formate r[32-byte]-s[32-byte]-v[1-byte] where v is recovery id.
    tx.signature = "0x" + sig + recoveryId;
```

## Broadcast the Tx

After signing the transaction with our dWallet and updating the `tx` object with the right signature format, all there's left to do is broadcast the transaction to the Ethereum Blockchain.

```typescript
    const response = await provider.broadcastTransaction(tx.serialized);
    console.log(`Transaction successful with hash: ${response.hash}`);
```

And that is it! You can view the transaction at: `https://sepolia.etherscan.io/tx/<response.hash>`
---
title: Use a dWallet on Ethereum
---

After [creating a dWallet](../your-first-dwallet.md#create-a-dwallet), you can derive the dWallet's Ethereum address,
create transactions from that address, sign them with the dWallet, and broadcast the signed transactions to the Ethereum
network.

## Setup

First, we need to set up the environment. Begin by importing the necessary functions:

```typescript
import { DWalletClient } from '@dwallet-network/dwallet.js/client';
import { Ed25519Keypair } from '@dwallet-network/dwallet.js/keypairs/ed25519';
import { requestSuiFromFaucetV0 as requestDwltFromFaucetV0 } from '@dwallet-network/dwallet.js/faucet';
import { ethers } from "ethers";

var elliptic = require('elliptic');

import {
  createDWallet,
  getOrCreateEncryptionKey,
  storeEncryptionKey,
  setActiveEncryptionKey,
  EncryptionKeyScheme,
  createActiveEncryptionKeysTable,
  submitDWalletCreationProof,
  submitTxStateProof,
  recoveryIdKeccak256,
} from '@dwallet-network/dwallet.js/signature-mpc';
```

## Get the dWallet's Ethereum Address

To create transactions on the Ethereum network, we need an Ethereum address. The Ethereum address is generated by
hashing your public key in `sha3` format and taking the last 40 bytes of the result.

```typescript
// get the dWallet object
const dwallet = await dwalletClient.getObject({ id: dwalletId, options: { showContent: true } });
if (dwallet?.data?.content?.dataType == "moveObject") {
  // Get the public key
  // @ts-ignore
  const pubkeyhex = Buffer.from(dwallet?.data?.content?.fields["public_key"]).toString("hex");

  // The public key is in its compressed form so we uncompress it, as the address is derived from the uncompressed public key.
  var ec = new elliptic.ec("secp256k1");
  var publicKeyUncompressed = ec.keyFromPublic(pubkeyhex, "hex").getPublic(false, "hex");

  let pubkey = Buffer.from(publicKeyUncompressed, "hex");

  // Here we are doing keccak256 hashing of our ECDSA public key
  const ethereumAddress = ethers.getAddress(ethers.keccak256(pubkey).slice(-40));

  console.log("dWallet Ethereum address is", ethereumAddress);
}
```

## Access the Ethereum Network

We need a service that offers a web API for accessing the Ethereum blockchain. Providers allow connecting to the
blockchain, simplifying development. In the following example, we use `EtherscanProvider` with the Sepolia network,
which is Ethereum's proof-of-authority testnet.

```typescript
    const provider = new ethers.EtherscanProvider(ethers.Network.from("sepolia"), "");

// Get chainId from network
const chainId = (await provider.getNetwork()).chainId;
```

## Sign a Tx

You can create transactions using the [
`ethers` library documentation on Transactions](https://docs.ethers.org/v5/api/providers/types/#types--transactions).
Once we have the transaction object, we sign the bytes of the hash generated from the transaction.

```typescript
    const tx = new ethers.Transaction();
// * fill the tx parameters here *

// `tx.unsignedSerialized` is a hex string starting with `0x`, so we remove it by slicing the first two characters before parsing it as a hex string into a byte array.
const bytes = Uint8Array.from(Buffer.from(tx.unsignedSerialized.slice(2), "hex"));

// Sign the transaction bytes
const signMessagesIdKECCAK256 = await createPartialUserSignedMessages(dkg?.dwalletID!, dkg?.decentralizedDKGOutput!,
  new Uint8Array(dkg?.secretKeyShare!), [bytes], "KECCAK256", keypair, dwalletClient);
const sigKECCAK256 = await approveAndSign(dkg?.dwalletCapID!, signMessagesIdKECCAK256!, [bytes], dkg?.dwalletID!, "KECCAK256", keypair, dwalletClient);
const sig = Buffer.from(sigKECCAK256?.signatures[0]).toString("hex");

// @ts-ignore
const recoveryId = "0" + recoveryIdKeccak256(dwallet?.data?.content?.fields["public_key"], bytes, sigKECCAK256?.signatures[0]).toString(16);

// Serialized signature in formate r[32-byte]-s[32-byte]-v[1-byte] where v is recovery id.
tx.signature = "0x" + sig + recoveryId;
```

## Broadcast the Tx

After signing the transaction with our dWallet and updating the `tx` object with the correct signature format, the final
step is to broadcast the transaction to the Ethereum blockchain.

```typescript
    const response = await provider.broadcastTransaction(tx.serialized);
console.log(`Transaction successful with hash: ${response.hash}`);
```

And that is it! You can view the transaction at: `https://sepolia.etherscan.io/tx/<response.hash>`
